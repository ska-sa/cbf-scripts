#!/bin/bash


if [ -n "$1" ] ; then
  export KATCP_LABEL="cmc-${1}"
else
  export KATCP_LABEL=cmc-subordinate
fi

configuration=${CMC_CONFIG:-/etc/cmc.conf}

if [ -f "${configuration}" ] ; then
  source "${configuration}"

  if [ "${state/verbose-log/}" != "${state}" ] ; then
    set -x
  fi

else
  kcpmsg -l fatal "unable to locate ${configuration} thus making things up"
  set -x

  if [ ! -d "${CORR_TEMPLATE}" ] ; then
    CORR_TEMPLATE=../tests/corr-templates/
  fi

fi

### essential declarations ##############################

declare -a -r resource_types=(roach skarab)

# valid command names and their minimum parameter count
declare -A -r command_set=([digitiser-synch-epoch]=1 [instrument-list]=1 [instrument-probe]=2 [instrument-activate]=2)

declare -a command_vector
declare -i command_size=0

### queue library #######################################

declare -a queue_data
declare -i queue_tail=0

function clear_queue()
{
  local i=0

  while [ "${i}" -lt "${queue_tail}" ] ; do
    unset queue_data[${i}]
    i=$[i+1]
  done

  queue_tail=0
}

function add_queue()
{
  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "no parameters"
    return 1
  fi

  queue_data[${queue_tail}]="$*"

  kcpmsg -l debug "queue[${queue_tail}]: $*"

  queue_tail=$[queue_tail+1]
}

function show_queue()
{
  local i

  kcpmsg -l debug "#### dump start ####"

  i=0
  while [ "${i}" -lt "${queue_tail}" ] ; do
    kcpmsg -l debug "queue[${i}]: ${queue_data[${i}]}"
    i=$[i+1]
  done

  kcpmsg -l debug "#### dump end ####"
}

### error stack #########################################

declare -a failure_stack
declare -i failure_depth=0

function push_failure()
{
  failure_depth=$[failure_depth+1]
  failure_stack[${failure_depth}]=0
}

# pop failure to be used in if statement where we return or we are no longer interested in error codes
# clear failure to be used in if statements where there is no return

function pop_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  if [ "${failure_depth}" -gt "0" ] ; then
    failure_depth=$[failure_depth-1]
  else
    kcpmsg -l warn "unwound stack too far"
  fi

  return ${result}
}

function clear_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  failure_stack[${failure_depth}]=0

  return ${result}
}

function set_failure()
{
  failure_stack[${failure_depth}]=$[failure_stack[${failure_depth}]+1]
}

### transform line into vector ##########################

function make_vector()
{
  local i

  i=0
  while [ ${i} -lt ${command_size} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done

  command_size=0
  while [ $# -gt 0 ] ; do
    command_vector[${command_size}]=$1
    command_size=$[command_size+1]
    shift
  done

  kcpmsg -l debug "parsed ${command_size} parameters"
}

### io functions with failure stack #####################

send_count=0

function send_request()
{
  local name="$1"

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  if [ "${send_count}" -gt 0 ] ; then
    kcpmsg -l warn "sending ${send_count} request(s) without waiting for reply"
  fi

  send_count=$[send_count+1]

  echo -n "?${name}"
  shift

  while [ $# -gt 0 ] ; do
    echo -n " ${1// /-}"
    shift
  done

  echo
}

function retrieve_reply()
{
  local name="$1"
  local line art reply code
  local -a vector

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    elif [ "${art}" = "!" ] ; then
      vector=(${line})
      reply=${vector[0]}
      if [ "${reply:1}" = "${name}" ]; then
        send_count=$[send_count-1]
        code=${vector[1]}
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi
      else
        kcpmsg -l warn "discarding unexpected response ${reply:1}"
      fi
    fi
  done
}

declare -A inform_result

function retrieve_inform()
{
  local name="$1"
  local match="$2"
  local del line label
  local -a vector

  for del in "${!inform_result[@]}" ; do
    unset inform_result[${del}]
  done

  while read line ; do
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#${name}" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${match}" = "${label}" ] ; then
          inform_result[${label}]="${line#* * }"
        fi
      elif [ "${vector[0]}" = "!${name}" ] ; then
        send_count=$[send_count-1]
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi
      else
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

declare -A var_result

function fetch_var()
{
  local del line label match
  local -a vector

  for del in "${!var_result[@]}" ; do
    unset var_result[${del}]
  done

  if [ "$1" = '-a' ] ; then
    shift
    echo "?var-show"
  else
    echo "?var-show $1"
  fi

  match=$1

  while read line ; do
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#var-show" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${label}" != "${label#${match}}" ] ; then
          var_result[${label}]="${vector[2]}"
        fi
      elif [ "${vector[0]}" = "!var-show" ] ; then
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi
      else
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

### support functions - subarray name ###################

function setup_name()
{
  push_failure
  fetch_var "subordinate"

  if ! pop_failure ; then
    kcpmsg -l error "unable to indentify subarray"
    adjust_sensors
    return 1
  fi

  SUBARRAY="${var_result[subordinate]}"
  if [ -z "${SUBARRAY}" ] ; then
    kcpmsg -l error "malformed subarray identification ${var_result[*]}"
    adjust_sensors
    return 1
  fi

  export SUBARRAY

  return 0
}

### support functions ###################################

# requirements:instrument:type   - number of resources needed of type

push_failure
send_request   var-declare  "*requires*"  map
retrieve_reply var-declare
send_request   var-declare  "*products*"  map
retrieve_reply var-declare

if ! pop_failure ; then
  kcpmsg -l error "unable to declare instrument property variables"
  return 1
fi

function setup_instruments()
{
  local instrument template geometry art count top available product i required

  if [ "${#instruments_deployed[@]}" -le 0 ] ; then
    kcpmsg -l fatal "no instruments deployed"
    return 1
  fi

  push_failure

  fetch_var "inputs"

  if ! pop_failure ; then
    kcpmsg -l error "unable to determine number of inputs"
    return 1
  fi

  geometry="${#var_result[*]}"

  if [ "${geometry}" -le 0 ] ; then
    kcpmsg -l error "regarding ${geometry} as an unreasonable number of inputs"
    return 1
  fi

  kcpmsg -l info "working on subarray with ${geometry} inputs"

  push_failure

  available=0
  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    kcpmsg -l debug "checking templates for instrument ${instrument}"

    if [ -f ${template} ] ; then

# TODO: maybe use ike here too ?
      top=$(cat $template  | tr ',=' '\n' | grep INPUT[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

      if [ -z "${top}" ] ; then
        kcpmsg -l fatal "unable to determine input count for instrument ${instrument}"
      else
        count=$[top+1]

        kcpmsg "instrument ${instrument} uses ${count} inputs"
      fi

      if [ "${count}" = "${geometry}" ] ; then

        send_request   var-declare requires map    ":${instrument}"
        retrieve_reply var-declare

        send_request   var-declare products array  ":${instrument}"
        retrieve_reply var-declare

        i=0
        for product in $(ike -o -k output_products $template) ; do
          send_request   var-set products "${product}" string ":${instrument}#${i}"
          retrieve_reply var-set
          i=$[i+1]
        done

        if [ "${i}" -le 0 ] ; then
          kcpmsg -l error "no data products discoverable in instrument ${instrument}"
        fi

        required=0
        for art in ${resource_types[*]} ; do

# TODO: maybe use ike here too ?
          top=$(cat $template  | tr ',=' '\n' | grep ${art^^}[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

          if [ -z "${top}" ] ; then
            kcpmsg "instrument ${instrument} does not appear to need any dynamic resources of type ${art}"
          else
            required=$[top+1]

            kcpmsg "instrument ${instrument} requires ${required} dynamically allocated ${art} resources"

            send_request   var-set requires "${required}" string ":${instrument}:${art}"
            retrieve_reply var-set
          fi
        done
#         if [ "${required}" -le 0 ] ; then
#           if [ "${state/missing-roaches/}" = "${state}" ] ; then
#             kcpmsg -l fatal "unable to determine resource needs for instrument ${instrument}"
#             set_failure
#           fi
#         fi


      else
        kcpmsg "ignorning instrument ${instrument} as it requires ${count} inputs but we are using ${geometry}"
      fi

    else
      kcpmsg -l fatal "no template available for instrument ${instrument}"
    fi

  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to determine instrument layouts"
    return 1
  fi

  return 0
}

# function update_git_versions()
# {
#   local v
#
#   v=$(cd ${BITSTREAM_DIR:-/srv/mkat_fpga} ; git describe --always --tags --long --dirty)
#
#   if [ -n "${v}" ] ; then
#     echo "?var-set gateware-images* ${v} string"
#     get_katcp_reply var-set
#   fi
#
#
#   v=$(cd ${CORR_TEMPLATE} ; git describe --always --tags --long --dirty)
#
#   if [ -n "${v}" ] ; then
#     echo "?var-set correlator-configs* ${v} string"
#     get_katcp_reply var-set
#   fi
# }
#

function setup_sync()
{
  local value epoch status

  kcpmsg -l debug "initialising synchronisation variable"

  push_failure

  send_request   var-declare "*synchronisation-epoch*" sensor,map
  retrieve_reply var-declare

  send_request   var-set "*synchronisation-epoch*" "synchronisation time" string :help
  retrieve_reply var-set

  send_request   var-set "*synchronisation-epoch*"  float string :type
  retrieve_reply var-set

  if [ -n "${dmc_address}" ] ; then

    value=$(kcpcmd -r -s ${dmc_address} sensor-value synchronisation-epoch | grep sensor-value | cut -f5- -d ' ')
    status="${value% *}"
    epoch="${value#* }"
  fi

  if [ -n "${status}" -a -n "${epoch}" ] ; then

    send_request   var-set "*synchronisation-epoch*"  "${epoch}"  string :value
    retrieve_reply var-set

    send_request   var-set "*synchronisation-epoch*"  "${status}" string :status
    retrieve_reply var-set
  else

    send_request   var-set "*synchronisation-epoch*"  unknown string :status
    retrieve_reply var-set

    send_request   var-set "*synchronisation-epoch*"  0 string :value
    retrieve_reply var-set
  fi

  if ! pop_failure  ; then
    kcpmsg -l error "unable to generate synchronisation-epoch sensor"
    return 1
  fi

  return 0
}

### support functions ###################################

function setup_io()
{
  kcpmsg -l debug "configuring logging levels"

  push_failure

  send_request   client-config info-all
  retrieve_reply client-config
  send_request   log-limit off
  retrieve_reply log-limit

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to configure subordinate control verbosity"
    return 1
  fi

  return 0
}

### support functions: resources ########################

function add_static_resources()
{
  local art template status
  local -l resource
  local -i count

  template=$1

  kcpmsg "checking for static allocations of ${template##*/}"

  if [ ! -f "${template}" ] ; then
    kcpmsg -l error "${template} not a valid file"
    return 1
  fi

  if [ -z "${SUBARRAY}" ] ; then
    kcpmsg -l error "unable to identify own subarray"
    return 1
  fi

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query resource pool while accounting for static allocations"
    return 1
  fi

  push_failure

  for art in ${resource_types[*]} ; do
    count=0

    for resource in $(ike -o -k hosts ${template} | tr -s , '\n' | sort -u | grep ${art}) ; do
      status="${var_result[resources:${resource}:status]}"

      if [ -n "${status}" ] ; then
        if [ "${status}" != up ] ; then
          kcpmsg -l error "expect problems as resource ${resource} not up but statically allocated"
        fi

        send_request   var-set  resources "${SUBARRAY}" string ":${resource}:holder"
        retrieve_reply var-set

        count=$[count+1]

      else
        kcpmsg -l error "ignoring statically allocated resource ${resource} as it is undetectable"
      fi

    done

    if [ "${count}" -gt 0 ] ; then
      kcpmsg "marked an extra ${count} ${art} resources in use as they are statically allocated"
    fi
  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to allocate all static resources to subarray"
    return 1
  fi

  kcpmsg "completed static allocation check"

  return 0
}

### support functions: sensors ##########################

function setup_sensors()
{
  push_failure

  send_request   var-declare "*device-status*"      "sensor,map"
  retrieve_reply var-declare

  send_request   var-set device-status   "system\_health" string ":help"
  retrieve_reply var-set
  send_request   var-set device-status    discrete   string ":type"
  retrieve_reply var-set
  send_request   var-set device-status    nominal    string ":status"
  retrieve_reply var-set
  send_request   var-set device-status    ok         string ":value"
  retrieve_reply var-set

  send_request   var-set device-status    ok         string ":range#0"
  retrieve_reply var-set
  send_request   var-set device-status    degraded   string ":range#1"
  retrieve_reply var-set
  send_request   var-set device-status    fail       string ":range#2"
  retrieve_reply var-set


  send_request   var-declare "*instrument-state*"    "sensor,map"
  retrieve_reply var-declare

  send_request   var-set instrument-state "subarray\_instrument\_state" string :help
  retrieve_reply var-set
  send_request   var-set instrument-state string     string ":type"
  retrieve_reply var-set
  send_request   var-set instrument-state unknown    string ":status"
  retrieve_reply var-set
  send_request   var-set instrument-state none       string ":value"
  retrieve_reply var-set

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to initialse status sensors"
    return 1
  fi

  return 0
}

function adjust_sensors()
{
  local status value

  if [ "$#" -lt 1 ] ; then
    status="error"
    value=""
  elif [ "$#" -eq 1 ] ; then
    status="$1"
    value=""
  else
    status="$1"
    value="$2"
  fi

  push_failure

# TODO: update device-status too

  send_request   var-set instrument-state "${status}" string :status
  retrieve_reply var-set

  if [ -n "${value}" ] ; then
    send_request   var-set instrument-state "${value}" string :value
    retrieve_reply var-set
  fi

  if ! pop_failure  ; then
    kcpmsg -l error "unable to update instrument-sensor"
    return 1
  fi

  return 0
}

function activate_servlet_sensors()
{
  local key remote

  remote=$1

  if [ -z "${remote}" ] ; then
    kcpmsg "need a remote party to query"
    return 1
  fi

  push_failure

  send_request relay "${remote}" relay "${remote}" sensor-list
  retrieve_inform relay

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to interrogate sensors of ${remote}"
    return 1
  fi

  push_failure

# risky, we assume inform_result isn't clobbered
  for key in "${!inform_result[@]}" ; do
    send_request relay "${remote}" relay "${remote}" sensor-sampling "${key}" "auto"
    retrieve_inform relay
  done

  if ! pop_failure ; then
    kcpmsg -l warn "unable to subscribe to sensors of ${remote}"
    return 1
  fi

  return 0
}

### api functions ### sync epoch ########################

function digitiser_synch_epoch()
{
  local epoch

  shift

  if [ "$#" -lt 1 ] ; then
    kcpmsg -l warn "require an epoch to set where value is available in synchronisation-epoch sensor"
    echo "!digitiser-synch-epoch fail"
    return 1
  fi

  epoch="$1"

  push_failure

  send_request   var-set "*synchronisation-epoch*"  "${epoch}"  string :value
  retrieve_reply var-set

  send_request   var-set "*synchronisation-epoch*" nominal string :status
  retrieve_reply var-set

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to set epoch variable"
    echo "!digitiser-synch-epoch fail"
    return 1
  fi

  kcpmsg -l info "will use epoch ${epoch}"


  echo "!digitiser-synch-epoch ok"
}

### api functions ### instrument ########################

function instrument_list()
{
  local instrument i j
  local -A vector

  shift

  setup_instruments

  push_failure

  fetch_var "products"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to retrieve product information"
    echo "!instrument-list fail"
    return 1
  fi

  for instrument in "${!var_result[@]}" ; do
    j=${instrument#products:}
    i=${j%%#*}
    vector[$i]="${vector[$i]} ${var_result[${instrument}]}"
  done

  for instrument in "${!vector[@]}" ; do
    echo "#instrument-list ${instrument} ${vector[${instrument}]}"
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  local instrument art resource t
  local -A wants has
  local -i sofar

  shift

  setup_instruments

  push_failure

  instrument=$1

  fetch_var "requires:${instrument}"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve resource requirement information for instrument ${instrument}"
    echo "!instrument-probe fail unknown-item"
    return 1
  fi

  for art in ${resource_types[*]} ; do
    wants[${art}]=${var_result[requires:${instrument}:${art}]}
    if [ -n "${wants[${art}]}" ] ; then
      kcpmsg "instrument ${instrument} requires "${wants[${art}]}" resources of type ${art}"
    else
      wants[${art}]=0
    fi
    has[${art}]=0
  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query current resource set while checking availabilty for ${instrument}"
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = status ] ; then
      if [ "${var_result[${resource}]}" = up ] ; then
        t=${resource%:*}
        if [ -z "${var_result[${t}:holder]}" ] ; then
          sofar=${has[${var_result[${t}:type]}]}
          has[${var_result[${t}:type]}]=$[sofar+1]
        fi
      fi
    fi
  done

  push_failure

  for art in ${resource_types[*]} ; do
    if [ "${has[${art}]}" -ge "${wants[${art}]}" ] ; then
      kcpmsg "can supply ${has[${art}]} ${art} resources for ${instrument}"
    else
      kcpmsg "unable to supply ${wants[${art}]} ${art} resources for ${instrument} have only ${has[${art}]}"
      set_failure
    fi
  done

  if ! pop_failure ; then
    echo "!instrument-probe ok oversubscribed"
    return 0
  fi

  echo "!instrument-probe ok sufficient"
  return 0
}

function instrument_activate()
{
  local instrument art resource t n nextport label status
  local -A wants
  local epoch extras

  shift

  instrument=$1

  if [ -z "${SUBARRAY}" ] ; then
    kcpmsg -l error "unable to identify own subarray while activating instrument ${instrument}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  if [ -n "${INSTRUMENT}" ] ; then
    kcpmsg -l error "unable to launch another instrument ${instrument} as only one instrument per subordinate is supported"
    echo "!instrument-activate fail already-exists"
    adjust_sensors
    return 1
  fi

  INSTRUMENT=${instrument}
  export INSTRUMENT

  setup_instruments

  push_failure
  fetch_var "inputs"
  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve set of inputs while initialising instrument ${instrument}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  for input in "${!var_result[@]}" ; do
    n=${input##*#}
    eval export INPUT${n}=${var_result[${input}]}
  done

  push_failure
  fetch_var "requires:${instrument}"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve resource requirement information for instrument ${instrument}"
    echo "!instrument-activate fail unknown-item"
    adjust_sensors
    return 1
  fi

  for art in ${resource_types[*]} ; do
    wants[${art}]=${var_result[requires:${instrument}:${art}]}
    if [ -n "${wants[${art}]}" ] ; then
      kcpmsg "instrument ${instrument} requires ${wants[${art}]} resources of type ${art}"
    else
      wants[${art}]=0
    fi
  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query current resource set while checking availabilty for ${instrument}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = status ] ; then
      if [ "${var_result[${resource}]}" = up ] ; then
        t=${resource%:*}
        if [ -z "${var_result[${t}:holder]}" ] ; then
          art=${var_result[${t}:type]}
          n=${wants[${art}]}
          if [ "$n" -gt 0 ] ; then
            push_failure

            send_request   var-set  resources "${SUBARRAY}" string "${t#resources}:holder"
            retrieve_reply var-set

            if pop_failure ; then
              wants[${art}]=$[n-1]
              eval export ${art^^}$[n-1]=${t#resources}
            fi
          fi
        fi
      fi
    fi
  done

  for art in ${resource_types[*]} ; do
    if [ "${wants[${art}]}" -gt 0 ] ; then
      kcpmsg -l error "insufficient resources to launch ${instrument} as we are short of ${wants[${art}]} ${art} resources"
      echo "!instrument-activate fail oversubscribed"
      adjust_sensors
      return 1
    fi
  done

  if ! add_static_resources "${CORR_TEMPLATE}/${INSTRUMENT}" ; then
    kcpmsg -l error "static resource tracking failed"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  PORT=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)
  export PORT

  kcpmsg "selecting port ${PORT} for instrument ${INSTRUMENT} of array ${SUBARRAY}"

  if ! cmc-config ${CORR_TEMPLATE}/${INSTRUMENT} ${CORR_DIR}/${SUBARRAY}-${INSTRUMENT} ; then
    kcpmsg -l error "unable to generate config for instrument ${INSTRUMENT} in subarray ${SUBARRAY}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

### TODO: organise multicast ranges

  push_failure

  send_request   client-exec ${SUBARRAY}-${INSTRUMENT} ${SUBARRAY} kcprun -o auto corr2_servlet.py -p ${PORT}
  retrieve_reply client-exec

  send_request   client-config client ${SUBARRAY}-${INSTRUMENT}
  retrieve_reply client-config

  sleep 3

  label=instrument

  send_request   client-connect localhost:${PORT} "${SUBARRAY}" "${label}"
  retrieve_reply client-connect

  send_request   client-config client "${label}"
  retrieve_reply client-config

  send_request   client-config fixed  "${label}"
  retrieve_reply client-config

  if ! pop_failure ; then
    kcpmsg -l error "unable to launch servlet for instrument ${INSTRUMENT}"
    echo "!instrument-activate fail task-start"
# TODO: halt the servlet
    adjust_sensors
    return 1
  fi

# TODO would be nice to use internal relay, but no timeout ...
  if ! kcpcmd -i -k -f -t 300 -r -s localhost:${PORT} create ${CORR_DIR}/${SUBARRAY}-${INSTRUMENT} ; then
    kcpmsg -l error "unable to load config for instrument ${INSTRUMENT} in subarray ${SUBARRAY}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  push_failure

  fetch_var "synchronisation-epoch"

  if ! pop_failure ; then
# we probably should terminate here
    kcpmsg -l error "no synchronisation epoch seems to be set"
  else
    kcpmsg -l info "got a synchronisation epoch"

    if [ "${var_result[synchronisation-epoch:status]}" != nominal ] ; then
      kcpmsg -l error "synchronisation epoch is not nominal"
    fi

    epoch="${var_result[synchronisation-epoch:value]}"

    if [ "${epoch%%.*}" -gt 0 ] ; then
      if kcpcmd -i -k -f -r -s localhost:${PORT} digitiser-synch-epoch "${epoch}" ; then
        kcpmsg "preliminary sync epoch set to ${epoch}"
      else
        kcpmsg -l error "servlet unwilling to accept epoch ${epoch}"
        echo "!instrument-activate fail read-logs"
        adjust_sensors
        return 1
      fi
    fi

  fi

  shift

  extras="$*"
  if [ -z "${extras}" ] ; then
# warning - hack, this disables qdr callibration
    extras="1 0 1 0"
  fi

  kcpmsg -l warn "waiting for initialisation ${extras} ... patience"

  if ! kcpcmd -i -k -f -t 300 -r -s localhost:${PORT} initialise ${extras} ; then
    kcpmsg -l error "unable to initialise instrument ${INSTRUMENT} with options ${extras}"
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  push_failure

  send_request   client-config prefixed "${label}"
  retrieve_reply client-config

#  send_request   client-config native "${label}"
#  retrieve_reply client-config

  send_request   relay "${label}" relay "${label}" version-list
  retrieve_reply relay

  send_request   client-config fixed "${label}"
  retrieve_reply client-config

  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve version information"
    status=warn
  fi

  push_failure

  send_request   client-rename corr "${label}"
  retrieve_reply client-rename

  if ! pop_failure ; then
    kcpmsg -l warn "unable to relabel and configure servlet"
# TODO: kill the corr instance to release resources
    echo "!instrument-activate fail read-logs"
    adjust_sensors
    return 1
  fi

  label=corr

  status=nominal
  if [ "${state/no-sensors/}" = "${state}" ] ; then
    extraport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

    kcpmsg "selecting ${extraport} for sensor routines"

    push_failure

    send_request   client-exec "monitor-${SUBARRAY}-${INSTRUMENT}" "${SUBARRAY}" kcprun -e debug -o debug -n "CORR2INI=${CORR_DIR}/${SUBARRAY}-${INSTRUMENT}" corr2_sensor_servlet.py -p "${extraport}"
    retrieve_reply client-exec

    send_request   client-config client "monitor-${SUBARRAY}-${INSTRUMENT}"
    retrieve_reply client-config

    sleep 2

    label=monitor

    send_request   client-connect "localhost:${extraport}" "${SUBARRAY}" "${label}"
    retrieve_reply client-connect

    send_request   relay "${label}" relay "${label}" watchdog
    retrieve_reply relay

    send_request   client-config client   "${label}"
    retrieve_reply client-config

    send_request   client-config fixed    "${label}"
    retrieve_reply client-config

    if pop_failure ; then
      if ! activate_servlet_sensors "${label}" ; then
        kcpmsg -l warn "unable to subscribe to sensors of ${label}"
        status=warn
      fi
    else
      kcpmsg -l warn "sensors loop initialisation failed for instrument ${INSTRUMENT} but going on anyway"
      status=warn
    fi

  else
    kcpmsg -l warn "sensor servlet inhibited by configuration"
  fi

  kcpmsg "instrument activated"

  echo "!instrument-activate ok"
  adjust_sensors "${status}" "${instrument}"
}

### main loop ###########################################

setup_io
setup_name
setup_sync
setup_sensors

while read line ; do
  add_queue ${line}
#  show_queue

  k=0
  while [ "${k}" -lt "${queue_tail}" ] ; do

    string=${queue_data[${k}]}
    k=$[k+1]

    if [ "${string:0:1}" = "?" ] ; then

      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -z "${command_set[${cmd}]}" ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd} fail unknown-item"
      else
        if [ "${command_size}" -lt "${command_set[${cmd}]}" ] ; then
          kcpmsg -l warn "need at least ${command_set[${cmd}]} parameters for ${cmd} but saw only ${command_size}"
          echo "!${cmd} fail usage"
        else
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi
      fi

    fi

  done

  clear_queue

done
