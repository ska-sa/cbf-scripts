#!/bin/bash


if [ -n "$1" ] ; then
  export KATCP_LABEL="cmc-${1}"
else
  export KATCP_LABEL=cmc-subordinate
fi

configuration=${CMC_CONFIG:-/etc/cmc.conf}

if [ -f "${configuration}" ] ; then
  source "${configuration}"

  if [ "${state/verbose-log/}" != "${state}" ] ; then
    set -x
  fi

else
  kcpmsg -l fatal "unable to locate ${configuration} thus making things up"
  set -x

  if [ ! -d "${CORR_TEMPLATE}" ] ; then
    CORR_TEMPLATE=../tests/corr-templates/
  fi

fi

### essential declarations ##############################

declare -a -r resource_types=(roach skarab)

# valid command names and their minimum parameter count 
declare -A -r command_set=([instrument-list]=1 [instrument-probe]=2 [instrument-activate]=2)

declare -a command_vector
declare -i command_size=0

### queue library #######################################

declare -a queue_data
declare -i queue_tail=0

function clear_queue()
{
  local i=0

  while [ "${i}" -lt "${queue_tail}" ] ; do
    unset queue_data[${i}]
    i=$[i+1]
  done

  queue_tail=0
}

function add_queue()
{
  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "no parameters"
    return 1
  fi

  queue_data[${queue_tail}]="$*"

  kcpmsg -l debug "queue[${queue_tail}]: $*"

  queue_tail=$[queue_tail+1]
}

function show_queue()
{
  local i

  kcpmsg -l debug "#### dump start ####"

  i=0
  while [ "${i}" -lt "${queue_tail}" ] ; do
    kcpmsg -l debug "queue[${i}]: ${queue_data[${i}]}"
    i=$[i+1]
  done

  kcpmsg -l debug "#### dump end ####"
}

### error stack #########################################

declare -a failure_stack
declare -i failure_depth=0

function push_failure()
{
  failure_depth=$[failure_depth+1]
  failure_stack[${failure_depth}]=0
}

# pop failure to be used in if statement where we return or we are no longer interested in error codes
# clear failure to be used in if statements where there is no return

function pop_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  if [ "${failure_depth}" -gt "0" ] ; then
    failure_depth=$[failure_depth-1]
  else
    kcpmsg -l warn "unwound stack too far"
  fi

  return ${result}
}

function clear_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  failure_stack[${failure_depth}]=0

  return ${result}
}

function set_failure()
{
  failure_stack[${failure_depth}]=$[failure_stack[${failure_depth}]+1]
}

### transform line into vector ##########################

function make_vector()
{
  local i

  i=0
  while [ ${i} -lt ${command_size} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done

  command_size=0
  while [ $# -gt 0 ] ; do
    command_vector[${command_size}]=$1
    command_size=$[command_size+1]
    shift
  done

  kcpmsg -l debug "parsed ${command_size} parameters"
}

### io functions with failure stack #####################

send_count=0

function send_request()
{
  local name="$1"

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  if [ "${send_count}" -gt 0 ] ; then
    kcpmsg -l warn "sending ${send_count} request(s) without waiting for reply"
  fi

  send_count=$[send_count+1]

  echo "?$*"
}

function retrieve_reply()
{
  local name="$1"
  local line art reply code 
  local -a vector

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    elif [ "${art}" = "!" ] ; then
      vector=(${line})
      reply=${vector[0]}
      if [ "${reply:1}" = "${name}" ]; then
        send_count=$[send_count-1]
        code=${vector[1]}
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else
        kcpmsg -l warn "discarding unexpected response ${reply:1}"
      fi
    fi
  done
}

declare -A inform_result

function retrieve_inform()
{
  local name="$1"
  local match="$2"
  local del line label
  local -a vector

  for del in "${!inform_result[@]}" ; do
    unset inform_result[${del}]
  done

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#${name}" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${match}" = "${label}" ] ; then
          inform_result[${label}]="${line#* * }"
        fi
      elif [ "${vector[0]}" = "!${name}" ] ; then
        send_count=$[send_count-1]
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

declare -A var_result

function fetch_var()
{
  local del line
  local -a vector

  for del in "${!var_result[@]}" ; do
    unset var_result[${del}]
  done

  if [ "$1" = '-a' ] ; then
    shift
    echo "?var-show"
  else
    echo "?var-show $1"
  fi

  match=$1

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#var-show" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${label}" != "${label#${match}}" ] ; then
          var_result[${label}]="${vector[2]}"
        fi
      elif [ "${vector[0]}" = "!var-show" ] ; then
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

### support functions ###################################

# requirements:instrument:type   - number of resources needed of type

push_failure
send_request   var-declare  "*requires*"  map
retrieve_reply var-declare
send_request   var-declare  "*products*"      map
retrieve_reply var-declare

function setup_instruments()
{
  local instrument template geometry art count top available product i required

  if [ "${#instruments_deployed[@]}" -le 0 ] ; then
    kcpmsg -l fatal "no instruments deployed"
    return 1
  fi

  push_failure

  fetch_var "inputs"

  if ! pop_failure ; then
    kcpmsg -l error "unable to determine number of inputs"
    return 1
  fi

  geometry="${#var_result[*]}"

  if [ "${geometry}" -le 0 ] ; then
    kcpmsg -l error "regarding ${geometry} as an unreasonable number of inputs"
    return 1
  fi

  kcpmsg -l info "working on subarray with ${geometry} inputs"

  push_failure

  available=0
  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    kcpmsg -l debug "checking templates for instrument ${instrument}"

    if [ -f ${template} ] ; then

# TODO: maybe use ike here too ? 
      top=$(cat $template  | tr ',=' '\n' | grep INPUT[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

      if [ -z "${top}" ] ; then
        kcpmsg -l fatal "unable to determine input count for instrument ${instrument}"
      else 
        count=$[top+1]

        kcpmsg "instrument ${instrument} uses ${count} inputs"
      fi

      if [ "${count}" = "${geometry}" ] ; then

        send_request   var-declare requires map    ":${instrument}"
        retrieve_reply var-declare

        send_request   var-declare products array  ":${instrument}"
        retrieve_reply var-declare

        i=0
        for product in $(ike -o -k output_products $template) ; do
          send_request   var-set products "${product}" string ":${instrument}#${i}"
          retrieve_reply var-set
          i=$[i+1]
        done

        if [ "${i}" -le 0 ] ; then
          kcpmsg -l error "no data products discoverable in instrument ${instrument}"
        fi

        required=0
        for art in ${resource_types[*]} ; do

# TODO: maybe use ike here too ? 
          top=$(cat $template  | tr ',=' '\n' | grep ${art^^}[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

          if [ -z "${top}" ] ; then
            kcpmsg "instrument ${instrument} does not appear to need any resources of type ${art}"
          else 
            required=$[top+1]

            kcpmsg "instrument ${instrument} requires ${required} ${art} resources"

            send_request   var-set requires "${required}" string ":${instrument}:${art}"
            retrieve_reply var-set
          fi
        done
        if [ "${required}" -le 0 ] ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l fatal "unable to determine resource needs for instrument ${instrument}"
            set_failure
          fi
        fi


      else
        kcpmsg "ignorning instrument ${instrument} as it requires ${count} inputs but we are using ${geometry}"
      fi

    else
      kcpmsg -l fatal "no template available for instrument ${instrument}"
    fi

  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to determine instrument layouts"
    return 1
  fi

  return 0
}

# function update_git_versions()
# {
#   local v
#   
#   v=$(cd ${BITSTREAM_DIR:-/srv/mkat_fpga} ; git describe --always --tags --long --dirty)
# 
#   if [ -n "${v}" ] ; then
#     echo "?var-set gateware-images* ${v} string" 
#     get_katcp_reply var-set
#   fi
# 
# 
#   v=$(cd ${CORR_TEMPLATE} ; git describe --always --tags --long --dirty)
# 
#   if [ -n "${v}" ] ; then
#     echo "?var-set correlator-configs* ${v} string" 
#     get_katcp_reply var-set
#   fi
# }
# 

### api functions ### instrument ########################

function instrument_list()
{
  local instrument i j
  local -A vector

  shift

  setup_instruments

  push_failure

  fetch_var "products"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to retrieve product information"
    return 1
  fi

  for instrument in "${!var_result[@]}" ; do 
    j=${instrument#products:}
    i=${j%%#*}
    vector[$i]="${vector[$i]} ${var_result[${instrument}]}"
  done

  for instrument in "${!vector[@]}" ; do 
    echo "#instrument-list ${instrument} ${vector[${instrument}]}"
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  local instrument art resource t
  local -A wants has
  local -i sofar

  shift

  setup_instruments

  push_failure

  instrument=$1

  fetch_var "requires:${instrument}"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve resource requirement information for instrument ${instrument}"
    echo "!instrument-probe fail unknown-item"
    return 1
  fi

  for art in ${resource_types[*]} ; do
    wants[${art}]=${var_result[requires:${instrument}:${art}]}
    if [ -n "${wants[${art}]}" ] ; then
      kcpmsg "instrument ${instrument} requires "${wants[${art}]}" resources of type ${art}"
    else 
      wants[${art}]=0
    fi
    has[${art}]=0
  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query current resource set while checking availabilty for ${instrument}"
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = status ] ; then
      if [ "${var_result[${resource}]}" = up ] ; then
        t=${resource%:*}
        if [ -z "${var_result[${t}:holder]}" ] ; then
          sofar=${has[${var_result[${t}:type]}]}
          has[${var_result[${t}:type]}]=$[sofar+1]
        fi
      fi
    fi
  done

  push_failure

  for art in ${resource_types[*]} ; do
    if [ "${has[${art}]}" -ge "${wants[${art}]}" ] ; then
      kcpmsg "can supply ${has[${art}]} ${art} resources for ${instrument}"
    else 
      kcpmsg "unable to supply ${wants[${art}]} ${art} resources for ${instrument} have only ${has[${art}]}"
      set_failure
    fi
  done

  if ! pop_failure ; then
    echo "!instrument-probe ok oversubscribed"
    return 0
  fi

  echo "!instrument-probe ok sufficient"
  return 0
}

function instrument_activate()
{
  local instrument art resource t n
  local -A wants

  shift

  setup_instruments

  instrument=$1

  push_failure
  fetch_var "subordinate"
  if ! pop_failure ; then
    kcpmsg -l warn "unable to indentify subarray while initialising instrument ${instrument}"
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  SUBARRAY="${var_result[subordinate]}"
  if [ -z "${SUBARRAY}" ] ; then
    kcpmsg -l warn "malformed identification while initialising instrument ${instrument} with unknown values ${var_result[*]}"
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  export SUBARRAY

  push_failure
  fetch_var "inputs"
  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve set of inputs while initialising instrument ${instrument}"
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  for input in "${!var_result[@]}" ; do
    n=${input##*#}
    eval export INPUT${n}=${var_result[${input}]}
  done

  push_failure
  fetch_var "requires:${instrument}"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to retrieve resource requirement information for instrument ${instrument}"
    echo "!instrument-activate fail unknown-item"
    return 1
  fi

  for art in ${resource_types[*]} ; do
    wants[${art}]=${var_result[requires:${instrument}:${art}]}
    if [ -n "${wants[${art}]}" ] ; then
      kcpmsg "instrument ${instrument} requires "${wants[${art}]}" resources of type ${art}"
    else 
      wants[${art}]=0
    fi
  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query current resource set while checking availabilty for ${instrument}"
    echo "!instrument-activate fail read-logs"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = status ] ; then
      if [ "${var_result[${resource}]}" = up ] ; then
        t=${resource%:*}
        if [ -z "${var_result[${t}:holder]}" ] ; then
          art=${var_result[${t}:type]}
          n=${wants[${art}]}
          if [ "$n" -gt 0 ] ; then
            push_failure

            send_request   var-set  resources "${SUBARRAY}" string "${t#resources}:holder"
            retrieve_reply var-set

            if pop_failure ; then
              wants[${art}]=$[n-1]
              eval export ${art^^}$[n-1]=${t#resources}
            fi
          fi
        fi
      fi
    fi
  done

  for art in ${resource_types[*]} ; do
    if [ "${wants[${art}]}" -gt 0 ] ; then
      kcpmsg -l error "insufficient resources to launch ${instrument} as we are short of ${wants[${art}]} ${art} resources"
      echo "!instrument-activate fail oversubscribed"
      return 1
    fi
  done

### TODO: organise multicast ranges 
### ADDRESS? variables 
  
  echo "!instrument-activate fail not-done"
  return 1

  local epoch extras

  status=nominal

  if [ "$#" -lt 2 ] ; then
    kcpmsg -l error "insufficient arguments (special case)"
    echo "!instrument-activate fail usage"
    return
  fi

  validate_subarray_list
  validate_instruments
  validate_resource_set
  validate_resource_use
  validate_resource_free

  subarray=$1
  instrument=$2

  shift 2 

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg -l error "no information about instrument ${instrument} found"
    echo "!instrument-activate fail unknown-item"
    return
  fi

  if [ -z "${subarray_list[${subarray}]}" ] ; then
    kcpmsg -l error "subarray ${subarray} does not seem to exist"
    echo "!instrument-activate fail unknown-item"
    return
  fi

  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg -l warn "would need ${need} boards but only have ${have}"
    #echo "!instrument-activate ok oversubscribed"
    echo "!instrument-activate fail oversubscribed"
    return 1
  fi

  i=0

  unset resource_grab
  declare -a resource_grab

  while [ "$i" -lt "${need}" ] ; do
    resource_grab[$i]=${resource_free[$i]}
    i=$[i+1]
  done

  compound=${subarray_list[$subarray]}

  kcpmsg "about to configure instrument ${instrument} for ${subarray} with ${resource_grab[*]} resources and inputs ${compound//-/ }"
  
  nextport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

  kcpmsg "selecting port ${nextport} for instrument ${instrument} of array ${subarray}"

  if ! cmc-config ${subarray} ${instrument} ${nextport} ${compound//-/ } ${resource_grab[*]} ; then
    kcpmsg -l error "unable to generate config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

#echo "?client-exec ${subarray}-${instrument} ${subarray} network-cmc-corr-stub" ${CORR_DIR}/${subarray}-${instrument} ${nextport}
  echo "?client-exec ${subarray}-${instrument} ${subarray} kcprun -o auto corr2_servlet.py -p ${nextport}"
  if ! get_katcp_reply client-exec ; then
    echo "!instrument-activate fail task-start"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-config client ${subarray}-${instrument}"
  if ! get_katcp_reply client-config ; then
    status=warn
  fi

  sleep 3

  echo "?client-connect localhost:${nextport} ${subarray}"
  if ! get_katcp_reply client-connect ; then
    echo "!instrument-activate fail network"
    echo "?client-halt ${subarray}-${instrument}"
    get_katcp_reply client-halt 
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-config client localhost:${nextport}"
  if ! get_katcp_reply client-config ; then
    status=warn
  fi

  if ! kcpcmd -i -k -f -t 300 -r -s localhost:${nextport} create ${CORR_DIR}/${subarray}-${instrument} ; then 
    kcpmsg -l error "unable to load config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-rename corr localhost:${nextport}" 
  if ! get_katcp_reply client-rename ; then
    # TODO: kill the corr instance to release resources
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  if [ -n "${dmc_address}" ] ; then

    epoch=$(kcpcmd -r -s ${dmc_address} sensor-value synchronisation-epoch | grep sensor-value | cut -f5- -d ' ')
    if [ "${epoch% *}" = "nominal" ] ; then
      if kcpcmd -i -k -f -r -s localhost:${nextport} digitiser-synch-epoch "${epoch#* }" ; then 
        kcpmsg "preliminary sync epoch set to ${epoch#* }"
      else
        kcpmsg -l error "servlet unwilling to accept epoch ${epoch#* }"
        echo "!instrument-activate fail read-logs"
        adjust_instrument_sensors ${subarray} error
        return 1
      fi
    else
      kcpmsg -l error "${dmc_address} unable to provide a nominal epoch thus giving up on synchronsation"
      echo "!instrument-activate fail read-logs"
      adjust_instrument_sensors ${subarray} error
      return 1
    fi

  else
    kcpmsg -l warn "no dmc defined thus synchronisation not possible"
  fi


  extras="$*"
  if [ -z "${extras}" ] ; then
# warning - hack, this disables qdr callibration
    extras="1 0 1 0"
  fi

  kcpmsg -l warn "waiting for initialisation ${extras} ... patience"

  if ! kcpcmd -i -k -f -t 300 -r -s localhost:${nextport} initialise ${extras} ; then 
    kcpmsg -l error "unable to initialise instrument ${instrument} in subarray ${subarray} with options ${extras}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  if [ -n "${dmc_address}" ] ; then
    echo "?client-exec dmc-${subarray}-${instrument} ${subarray} kcpmpx -r -l dmc "${dmc_address}" -k -l cmc - -m -e cmc-dmc"
    if ! get_katcp_reply client-exec ; then
      kcpmsg -l warn "unable to launch dmc synchronisation helper"
      status=warn
    else
      kcpmsg "launching synchronisation dmc monitor"
    fi
  fi

  for board in ${resource_grab[*]} ; do
    kcpmsg "assigning resource ${board} to ${subarray}"
    resource_use[${board}]=${subarray}
  done

  make_instrument_sensors ${subarray} ${instrument}

  if [ "${state/no-sensors/}" = "${state}" ] ; then
    extraport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

    kcpmsg "selecting ${extraport} for sensor"

    echo "?client-exec monitor-${subarray}-${instrument} ${subarray} kcprun -e debug -o debug -n CORR2INI=${CORR_DIR}/${subarray}-${instrument} corr2_sensor_servlet.py -p ${extraport}"

    if ! get_katcp_reply client-exec ; then
      kcpmsg -l warn "unable to launch sensors for instrument ${instrument} in ${subarray} but going on anyway"
      status=warn
    fi

    echo "?client-config client monitor-${subarray}-${instrument}"
    if ! get_katcp_reply client-config ; then
      status=warn
    fi

    sleep 2

    echo "?client-connect localhost:${extraport} ${subarray}"
    if ! get_katcp_reply client-connect ; then
      status=warn
    fi

    echo "?relay localhost:${extraport} relay localhost:${extraport} watchdog"
    if ! get_katcp_reply relay ; then
      status=warn
    fi

    echo "?client-config client localhost:${extraport}"
    if ! get_katcp_reply client-config ; then
      status=warn
    fi

    echo "?client-rename corr-sensors localhost:${extraport}" 
    if ! get_katcp_reply client-rename ; then
      status=warn
    fi

    echo "?client-config fixed corr-sensors"
    if ! get_katcp_reply client-config ; then
      kcpmsg -l warn "unable to configure sensor monitor"
      status=warn
    fi

    kcpmsg "about to interrogate servlet sensors"

    activate_servlet_sensors corr-sensors

  else
    kcpmsg -l warn "sensor servlet inhibited by configuration"
  fi

  echo "!instrument-activate ok"

  adjust_instrument_sensors ${subarray} ${status} ${instrument}
}

### main loop ###########################################

push_failure
send_request   client-config info-all
retrieve_reply client-config
send_request   log-limit off
retrieve_reply log-limit
pop_failure  

while read line ; do 
  add_queue ${line}
  show_queue

  k=0
  while [ "${k}" -lt "${queue_tail}" ] ; do

    string=${queue_data[${k}]}
    k=$[k+1]

    if [ "${string:0:1}" = "?" ] ; then

      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -z "${command_set[${cmd}]}" ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd} fail unknown-item"
      else
        if [ "${command_size}" -lt "${command_set[${cmd}]}" ] ; then
          kcpmsg -l warn "need at least ${command_set[${cmd}]} parameters for ${cmd} but saw only ${command_size}"
          echo "!${cmd} fail usage"
        else
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi 
      fi

    fi

  done

  clear_queue
  
done
