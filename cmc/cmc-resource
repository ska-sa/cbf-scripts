#!/bin/bash

set -x

export KATCP_LABEL=cmc-resource

leases=${LEASE_FILE:-/var/lib/misc/dnsmasq.leases}
if [ ! -f ${leases} ] ; then
  leases=../stub/dnsmasq.leases-small
fi

# valid command names and their minimum parameter count 
declare -A -r command_set=([resource-reload]=1 [resource-list]=1)

declare -a command_vector
declare -i command_size=0

### queue library #######################################

declare -a queue_data
declare -i queue_tail=0

function clear_queue()
{
  local i=0

  while [ "${i}" -lt "${queue_tail}" ] ; do
    unset queue_data[${i}]
    i=$[i+1]
  done

  queue_tail=0
}

function add_queue()
{
  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "no parameters"
    return 1
  fi

  queue_data[${queue_tail}]="$*"

  kcpmsg -l debug "queue[${queue_tail}]: $*"

  queue_tail=$[queue_tail+1]
}

function show_queue()
{
  local i

  kcpmsg -l debug "#### dump start ####"

  i=0
  while [ "${i}" -lt "${queue_tail}" ] ; do
    kcpmsg -l debug "queue[${i}]: ${queue_data[${i}]}"
    i=$[i+1]
  done

  kcpmsg -l debug "#### dump end ####"
}

### error stack #########################################

declare -a failure_stack
declare -i failure_depth=0

function push_failure()
{
  failure_depth=$[failure_depth+1]
  failure_stack[${failure_depth}]=0
}

# pop failure to be used in if statement where we return or we are no longer interested in error codes
# clear failure to be used in if statements where there is no return

function pop_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  if [ "${failure_depth}" -gt "0" ] ; then
    failure_depth=$[failure_depth-1]
  else
    kcpmsg -l warn "unwound stack too far"
  fi

  return ${result}
}

function clear_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  failure_stack[${failure_depth}]=0

  return ${result}
}

function set_failure()
{
  failure_stack[${failure_depth}]=$[failure_stack[${failure_depth}]+1]
}

### transform line into vector ##########################

function make_vector()
{
  local i

  i=0
  while [ ${i} -lt ${command_size} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done

  command_size=0
  while [ $# -gt 0 ] ; do
    command_vector[${command_size}]=$1
    command_size=$[command_size+1]
    shift
  done

  kcpmsg -l debug "parsed ${command_size} parameters"
}

### io functions with failure stack #####################

send_count=0

function send_request()
{
  local name="$1"

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  if [ "${send_count}" -gt 0 ] ; then
    kcpmsg -l warn "sending ${send_count} request(s) without waiting for reply"
  fi

  send_count=$[send_count+1]

  echo "?$*"
}

function retrieve_reply()
{
  local name="$1"
  local line art reply code 
  local -a vector

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    elif [ "${art}" = "!" ] ; then
      vector=(${line})
      reply=${vector[0]}
      if [ "${reply:1}" = "${name}" ]; then
        send_count=$[send_count-1]
        code=${vector[1]}
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else
        kcpmsg -l warn "discarding unexpected response ${reply:1}"
      fi
    fi
  done
}

function retrieve_inform()
{
  local name="$1"
  local match="$2"
  local del line label
  local -a vector

  for del in "${!inform_result[@]}" ; do
    unset inform_result[${del}]
  done

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#${name}" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${match}" = "${label}" ] ; then
          inform_result[${label}]="${line#* * }"
        fi
      elif [ "${vector[0]}" = "!${name}" ] ; then
        send_count=$[send_count-1]
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

declare -A var_result

function fetch_var()
{
  local del line
  local -a vector

  for del in "${!var_result[@]}" ; do
    unset var_result[${del}]
  done

  if [ "$1" = '-a' ] ; then
    shift
    echo "?var-show"
  else
    echo "?var-show $1"
  fi

  match=$1

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#var-show" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${label}" != "${label#${match}}" ] ; then
          var_result[${label}]="${vector[2]}"
        fi
      elif [ "${vector[0]}" = "!var-show" ] ; then
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

### unused ##############################################

# if [ -n "${CMC_CONFIG}" ] ; then
#   source "${CMC_CONFIG}"
# else
#   kcpmsg "running standalone"
#   source ../misc/cmc.conf
# fi
# 
# 
# if [ "${state/verbose-log/}" != "${state}" ] ; then
#     set -x
# fi

### support functions ###################################

# resources:name:when       - last time we checked it 
# resources:name:status     - what the user status is
#
# resources:name:type       - what type of resource it is 
# resources:name:mode       - did the user decide its status

push_failure
send_request   var-declare  "resources*"  map,readonly
retrieve_reply var-declare

if ! pop_failure  ; then
  kcpmsg -l fatal "unable to declare essential resource tracking state"
  exit 1
fi

function check_resources()
{
  local -l board
  local now mode art status when fresh

  now=$(date +%s)

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    push_failure

    fetch_var "resources:${board}"
    fresh=0

    if ! clear_failure ; then
      send_request   var-set  "resources" roach  map    ":${board}"
      retrieve_reply var-set

      send_request   var-set  "resources" roach  string ":${board}:type"
      retrieve_reply var-set

      send_request   var-set  "resources" auto   string ":${board}:mode"
      retrieve_reply var-set

      mode=auto
      art=roach
      when=${now}
      status=unknown

    else 
      fresh=1

      mode="${var_result[resources:${board}:mode]}"
      art="${var_result[resources:${board}:type]}"
      when="${var_result[resources:${board}:when]}"
      status="${var_result[resources:${board}:status]}"

      if [ "${mode}" == auto ] ; then 
        if [ "$[when+checkperiod]" -le "${now}" ] ; then
          fresh=0
          send_request   var-delete  "resources:${board}" ":when"
          retrieve_reply var-delete 
          send_request   var-delete  "resources:${board}" ":status"
          retrieve_reply var-delete
        fi
      fi
    fi

    if [ "${fresh}" = "0" ] ; then
      if kcpcmd -i -r -f -t 2 -s "${board}" watchdog ; then
        status=up
      else 
        status=standby
      fi

      send_request   var-set      "resources" ${now}     string ":${board}:when"
      retrieve_reply var-set
      send_request   var-set      "resources" ${status}  string ":${board}:status"
      retrieve_reply var-set
    fi

    if ! pop_failure  ; then
      kcpmsg -l fatal "unable to update status of board ${board}"
    fi

  done
}

### api functions #######################################

function resource_reload()
{
  if check_resources ; then
    echo "!resource-reload ok"
  else
    echo "!resource-reload fail"
  fi
}

function resource_list()
{
  local key board tmp
  local -A vector

  check_resources 

  push_failure

  fetch_var "resources"

  for key in "${!var_result[@]}" ; do
    tmp=${key#resources:}
    board=${tmp%%:*}
    vector[${board}]="#resource-list ${board} ${var_result[resources:${board}:status]}"
  done

  for key in "${vector[@]}" ; do 
    echo "$key"
  done

  echo "!resource-list ok"
}

### main loop ###########################################

while read line ; do 
  add_queue ${line}
  show_queue

  k=0
  while [ "${k}" -lt "${queue_tail}" ] ; do

    string=${queue_data[${k}]}
    k=$[k+1]

    if [ "${string:0:1}" = "?" ] ; then

      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -z "${command_set[${cmd}]}" ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd} fail unknown-item"
      else
        if [ "${command_size}" -lt "${command_set[${cmd}]}" ] ; then
          kcpmsg -l warn "need at least ${command_set[${cmd}]} parameters for ${cmd} but saw only ${command_size}"
          echo "!${cmd} fail usage"
        else
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi 
      fi

    fi

  done

  clear_queue
  
done
