#!/bin/bash

#################################################

export KATCP_LABEL=cmc-primary

# valid command names and their minimum parameter count

declare -A -r command_set=([resource-list]=1 [resource-mark]=3 [subordinate-create]=3 [subordinate-list]=1 [subordinate-halt]=2 [instrument-list]=1 [instrument-probe]=2 [cmc-halt]=1)
declare -A -r command_help=([resource-list]="show processing resources (?resource-list [resource])" [resource-mark]="set availability of a processing resource (?resource-mark resource marking)" [subordinate-halt]="halt a subarray (?subordinate-halt [subarray])" [subordinate-list]="show subarrays (?subordinate-list)" [subordinate-create]="define and launch a subarray (?subordinate-create subarray [inputs]*)" [instrument-list]="show available instruments (?instrument-list)" [instrument-probe]="test if a group of instruments can currently be run (?instrument-probe [instruments]*)" [cmc-halt]="power down the cmc server (?cmc-halt)")

declare -A -r inform_set=([group-destroyed]=1)

# support function to sort var result #############

# declare var_flat
#
# function flatten_var()
# {
# # This is needed to work around that associative arrays are hashed, thus order no longer ok
# # Could be made less wasteful
#   local name
#
#   var_flat=""
#
#   for name in $(echo ${!var_result[*]} | tr -s ' ' '\n' | sort -V) ;
#     do var_flat="${var_flat} ${var_result[${name}]}"
#   done
# }

# support: auto-reload ##########################

declare -i config_file_time=$(date +%s)
declare -i template_dir_time=$(date +%s)

function recheck_configs()
{
  local current_time update

  update=""

  if [ -f "${configuration}" ] ; then

    current_time=$(stat -c %Y ${configuration})

    if [ -n "${current_time}" ] ; then
      if [ "${current_time}" -gt "${config_file_time}" ] ; then
        config_file_time=${current_time}
        if source "${configuration}" ; then
          kcpmsg "reloaded configuration ${configuration}"
          update=1
        else
          kcpmsg -l error "failed to reload configuration ${configuration}"
          return 1
        fi
      fi

      reload_resource_exclusions
    fi
  else
    kcpmsg -l error "no configuration available"
  fi

  if [ -d "${CORR_TEMPLATE}" ] ; then
    current_time=$(stat -c %Y ${CORR_TEMPLATE})
    if [ "${current_time}" -gt "${template_dir_time}" ] ; then
      template_dir_time=${current_time}
      update=1
    fi
  fi

  if [ -n "${update}" ] ; then
    reload_instruments
  fi
}

### hidden api functions ### resources ##################

function group_destroyed()
{
  local subarray resource board prefix now count list
  local -a roaches skarabs

  shift

  subarray="$1"

  if [ -z "${subarray}" ] ; then
    kcpmsg -l warn "unable to identify subarray to be released"
    return 1
  fi

  kcpmsg "invoking group destruction callback for ${subarray}"

  push_failure

  fetch_var "resources"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to query resource set while deallocating subarray ${subarray}"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        prefix=${resource%:*}
        if [ "${var_result[${prefix}:type]}" = roach ] ; then
          board=${prefix#resources:}
          roaches+=("${board}")
        elif [ "${var_result[${prefix}:type]}" = skarab ] ; then
          board=${prefix#resources:}
          skarabs+=("${board}")
        fi
      fi
    fi
  done

# if already programmed, things may take longer, thus run it in parallel
  list="${roaches[*]}"
  if [ -n "${list}" ] ; then
    kcppar -q -i -n -s "${list// /,}" -x progdev
  fi

# TODO: could we have a bulk skarab deprogram option ?

  count=0

  push_failure

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        prefix=${resource%:*}
        now=""
        if [ "${var_result[${prefix}:type]}" = roach ] ; then
          board=${prefix#resources:}

          if kcpcmd -f -kr -s ${board}:7147 progdev ; then
            now=$(date +%s)
          else
            kcpmsg -l error "unable to deprogram roach ${board} which was part of array ${subarray}"
            set_failure
          fi

        elif [ "${var_result[${prefix}:type]}" = skarab ] ; then
          board=${prefix#resources:}
# WARNING: reboot of skarab takes too long, clear timeout so that the next resource check sees if given skarab is reachable
          kcprun -q -t 250 -j reboot_skarab.py ${board} 10
        fi

        send_request   var-delete  "${prefix}:when"
        retrieve_reply var-delete

# update check time on success case, otherwise force check the next time
        send_request   var-set     resources ${now:-0} string ":${board}:when"
        retrieve_reply var-set

        if [ -z "${now}" ] ; then
# redundant test; it must have been ready which now implies a mode auto
          if [ "${var_result[${prefix}:mode]}" = "auto" ] ; then
            send_request   var-delete  "${prefix}:status"
            retrieve_reply var-delete

            send_request   var-set   resources standby string ":${board}:status"
            retrieve_reply var-set
          fi

        fi

# this deletes the holder
        send_request   var-delete  "${resource}"
        retrieve_reply var-delete

        count=$[count+1]

      fi
    fi
  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to free all resources held by ${subarray}"
  else
    kcpmsg -l info "released ${count} resources held by ${subarray}"
  fi

# prints its own error messages
  release_multicast subarray
}

### api functions ### resources #########################

# function resource_reload()
# {
#   if check_resources ; then
#     echo "!resource-reload ok"
#   else
#     echo "!resource-reload fail"
#   fi
# }

function resource_list()
{
  local key board prefix setting

  shift

  check_resources

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "resources:${1,,}"
  else
    fetch_var "resources"
  fi

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve resource variables"
    echo "!resource-list fail"
  fi

  for key in "${!var_result[@]}" ; do

    if [ "${key##*:}" = status ] ; then
      prefix="${key%:status}"
      board="${prefix#resources:}"

      if [ -n "${board}" ] ; then

        if [ "${var_result[${prefix}:mode]}" != "auto" ] ; then
          kcpmsg -l warn "resource ${board} is in held in mode ${var_result[${prefix}:mode]}"
        fi

        if [ -n "${var_result[${prefix}:holder]}" ] ; then
          echo "#resource-list ${board} ${var_result[${prefix}:status]} ${var_result[${prefix}:holder]}"
        else
          echo "#resource-list ${board} ${var_result[${prefix}:status]}"
        fi
      else
        kcpmsg -l error "problems processing resource status ${key}"
      fi
    fi
  done

  echo "!resource-list ok"
}

function resource_mark()
{
  local board status

  shift

  board=${1,,}
  status=$2

  push_failure

  fetch_var "resources:${board}"

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve resource ${board}"
    echo "!resource-mark fail unknown-item"
    return 1
  fi

  case "${status}" in
    (up)
      if [ -n "${resources_excluded[${board}]}" ] ; then
        kcpmsg -l warn "resource ${board} was excluded via configuration in ${configuration} thus not honouring this request"
        echo "!resource-mark fail"
        return 1
      fi

      if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
        if ! kcpcmd -k -r -i -s "${board}" watchdog >& /dev/null ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l error "roach resource ${board} unresponsive"
            echo "!resource-mark fail network"
            return 1
          fi
          kcpmsg -l warn "roach resource ${board} not responsive but taking it to be ok"
        fi
      elif [ "${var_result[resources:${board}:type]}" = "skarab" ] ; then
        if ! ping -c 1 "${board}" >& /dev/null ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l error "skarab resource ${board} unresponsive"
            echo "!resource-mark fail network"
            return 1
          fi
          kcpmsg -l warn "skarab resource ${board} not responsive but taking it to be ok"
        fi
      fi

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "up" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" up     string ":${board}:status"
        retrieve_reply var-set
      fi

# WARNING: introduces asymmetry: marking it up puts it into auto mode again
      if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" auto   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (standby)

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" standby  string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
#     (reset)
#
#       if [ "${var_result[resources:${board}:type]}" != roach ] ; then
#         kcpmsg -l warn "no way of resetting resource ${board}"
#         echo "!resource-mark fail read-logs"
#         return 1
#       fi
#
#       if [ -n "${var_result[resources:${board}:holder]}" ] ; then
#         kcpmsg -l warn "unwilling to reset resource ${board} as it is used by ${var_result[resources:${board}:holder]}"
#         echo "!resource-mark fail in-use"
#         return 1
#       fi
#
#       push_failure
#
#       if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
#         send_request   var-delete  "resources:${board}:status"
#         retrieve_reply var-delete
#
#         send_request   var-set  "resources" standby  string ":${board}:status"
#         retrieve_reply var-set
#       fi
#
#       if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
#         send_request   var-delete  "resources:${board}:mode"
#         retrieve_reply var-delete
#
#         send_request   var-set  "resources" auto   string ":${board}:mode"
#         retrieve_reply var-set
#       fi
#
#       if ! pop_failure ; then
#         kcpmsg -l error "unable to update resource state for ${board}"
#         echo "!resource-mark fail read-logs"
#         return 1
#       fi
#
#       if ! kcpcmd -k -i -r -s "$1" restart ; then
#         kcpmsg -l error "unable to restart resource ${board}"
#         echo "!resource-mark fail network"
#         return 1
#       fi
#
#       echo "!resource-mark ok"
#       return 0
#     ;;
    (*)
      kcpmsg -l error "unknown marking ${status} for resource ${board}"
      echo "!resource-mark fail usage"
      return 1
    ;;
  esac
}

### api functions ### subordinates ######################

function subordinate_list()
{
  local -A ports hosts groups
  local -a v
  local group port host key
  local count t i inputs

  shift

  push_failure

  send_request    listener-list "$*"
  retrieve_inform listener-list

  if ! pop_failure ; then
    echo "!subordinate-list fail"
    return 1
  fi

# WARNING: we assume one listener per group here

  kcpmsg -l debug "my keys are ${!inform_result[@]}"
  for key in "${!inform_result[@]}" ; do
    v=(${inform_result[${key}]})
    if [ -z "${v[2]}" ] ; then
      group="${key}"
    else
      group=${v[2]}
    fi

    ports[${key}]=${v[0]}
    hosts[${key}]=${v[1]}
    groups[${key}]=${group}
  done

  push_failure

  count=0
  for key in "${!groups[@]}" ; do

    group="${groups[${key}]}"

    fetch_var  "${group}*subordinate*"

    if clear_failure ; then

      subarray="${var_result[${group}*subordinate*]}"

      if [ -n "${subarray}" ] ; then

        if [ "${key}" != "${subarray}" ] ; then
          kcpmsg -l warn "possible consistency issue where listener label ${key} does not match subarray name ${subarray}"
        fi

        port=${ports[${group}]}
        host=${hosts[${group}]}

        kcpmsg -l debug "considering ${group} with listener ${host}:${port}"


        if [ "${host}" = "0.0.0.0" ] ; then
          unset host
        fi

        fetch_var "${group}*inputs*"
        i=0
        while [ "$i" -lt "${#var_result[*]}" ] ; do
          inputs="${inputs} ${var_result[${group}*inputs*#${i}]}"
          i=$[i+1]
        done

        if clear_failure ; then
          echo "#subordinate-list "${subarray}" ${host}${host:+:}${port} ${inputs}"
          count=$[count+1]
        fi

      fi

    fi
  done

  pop_failure

  if [ "${count}" -lt "$#"  ] ; then
    kcpmsg -l debug "was given $# parameters, could only list ${count} subarrays"
    echo "!subordinate-list fail unknown-array"
    return 1
  fi

  echo "!subordinate-list ok"
  return 0
}

function subordinate_create()
{
  local port key prefix group file
  local i t

  shift

# at the moment there is only one instrument per group
  key=$1
  group=${key}

  if ! recheck_configs ; then
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  if [ "${group}" = primary ] ; then
    kcpmsg -l warn "name ${group} reserved for internal use"
    echo "!subordinate-create fail already-exists"
    return 1
  fi

  push_failure

  send_request   group-list "${group}"
  retrieve_reply group-list

  if pop_failure ; then
    kcpmsg -l warn "array ${group} already in use"
    echo "!subordinate-create fail already-exists"
    return 1
  fi

  if [ -n "${CORR_DIR}" ] ; then
    for file in ${CORR_DIR}/${key}-* ; do
      if [ -f ${file} ] ; then
        if rm ${file} ; then
          kcpmsg -l debug "removing old config ${file}"
        else
          kcpmsg -l error "unable to remove old config file ${file}"
          echo "!subordinate-create fail read-logs"
          return
        fi
      fi
    done
  fi

  push_failure

  send_request   group-create "${group}"
  retrieve_reply group-create

  if ! pop_failure ; then
    kcpmsg -l warn "unable to create group ${group} for array"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  push_failure

# used to label a subarray group, so that halt can't be used to kill primary
  send_request   var-declare "${group}*subordinate*" string
  retrieve_reply var-declare

  send_request   var-set "${group}*subordinate*" "$key" string
  retrieve_reply var-set

  send_request   var-declare "${group}*inputs*" array
  retrieve_reply var-declare

  shift
  i=0

  while [ "$#" -ge 1 ] ; do
    send_request   var-set "${group}*inputs*" "$1" string "#$i"
    retrieve_reply var-set

    shift
    i=$[i+1]
  done

  if ! clear_failure ; then

    send_request   group-halt "${group}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to record inputs for group ${group}"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port:-7404}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    t="${key//[^0-9]/}"
    if [ "$t" -gt 0 ] ; then
      port=$[base_port+t]
      if [ "$port" -gt "${base_port}" ] ; then
        kcpmsg "selecting name derived port ${port}"
      else
        kcpmsg -l warn "malformed port ${port} thus falling back to automatic selection"
        port=0
      fi
    else
      kcpmsg "will select a free port for array other than rts"
      port=0
    fi
  fi

  push_failure

  send_request   listener-create "${key}" "${port}" "0.0.0.0" "${group}"
  retrieve_reply listener-create

  if [ "${port}" -le "0" ] ; then
    send_request listener-list "${key}"
    retrieve_inform listener-list "${key}"
    port=${inform_result[${key}]%% *}
    if [ "${port}" -le "0" ] ; then
      kcpmsg -l error "unable to determine port for ${key} - got ${result}"
      set_failure
    fi
  fi

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start listener for group ${group}"
    echo "!subordinate-create fail network"
    return 1
  fi

  send_request   client-exec subordinate ${key} cmc-subordinate ${key}
  retrieve_reply client-exec

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start control task for group ${group}"
    echo "!subordinate-create fail task-start"
    return 1
  fi

  pop_failure

# there is a chance this isn't needed with a proper mainloop
  sleep 0.1

  echo "!subordinate-create ok ${port}"
  return 0
}

function subordinate_halt()
{
  local group key

  shift

  key="$1"

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!subordinate-halt fail usage"
    return 1
  fi

  group="${key}"

  push_failure

  fetch_var "${group}*subordinate*"

  if ! pop_failure ; then
    kcpmsg -l error "could not locate variable suborinate in group ${group}"

    kcpmsg -l error "subarray ${key} not found and so not halted"

    echo "!subordinate-halt fail unknown-item"
    return 1
  fi

  push_failure

  send_request    group-halt "$key"
  retrieve_reply  group-halt

  if ! pop_failure ; then
    echo "!subordinate-halt fail read-logs"
    return 1
  fi

  echo "!subordinate-halt ok"
  return 0
}

### api functions ### instrument ########################

function instrument_list()
{
  local -A availability size instruments inputs outputs bandwidth_in bandwidth_out channels
  local key products prefix instrument problem tmp

  shift

  if ! recheck_configs ; then
    echo "!instrument-list fail read-logs"
    return 1
  fi

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "instruments:$1"
  else
    fetch_var "instruments"
  fi

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve instrument list"
    echo "!instrument-list fail read-logs"
    return 1
  fi

  for key in "${!var_result[@]}" ; do
    # extract instrument ID
    tmp=${key#instruments:}
    instrument=${tmp%%:*}

    prefix="instruments:${instrument}"

    instruments[${instrument}]=0

    # TODO: actually compute availability
    availability[${instrument}]="sufficient"

    # extract input size
    if [ "$key" == "${prefix}:input-size" ] ; then
      size[${instrument}]=${var_result[$key]}

    # extract input products
    elif [ "${key%#*}" == "${prefix}:input-products" ] ; then
      if [ -z "${inputs[${instrument}]}" ] ; then
        inputs[${instrument}]=${var_result[$key]}
      else
        inputs[${instrument}]=${inputs[${instrument}]},${var_result[$key]}
      fi

    # extract output products
    elif [ "${key%#*}" == "${prefix}:output-products" ] ; then
      if [ -z "${outputs[${instrument}]}" ] ; then
        outputs[${instrument}]=${var_result[$key]}
      else
        outputs[${instrument}]=${outputs[${instrument}]},${var_result[$key]}
      fi

    # extract input bandwidth
    elif [ "$key" == "${prefix}:input-bandwidth" ] ; then
      bandwidth_in[${instrument}]=${var_result[$key]}

    # extract output bandwidth
    elif [ "$key" == "${prefix}:output-bandwidth" ] ; then
      bandwidth_out[${instrument}]=${var_result[$key]}

    # extract channels
    elif [ "$key" == "${prefix}:channels" ] ; then
      channels[${instrument}]=${var_result[$key]}

    else
      kcpmsg -l debug "instrument field $key not used by listing"
    fi
  done

  problem=""
  for instrument in "${!instruments[@]}" ; do
    #check if some instrument field is missing
    if [[ -z "${availability[${instrument}]}" || -z "${size[${instrument}]}" || -z "${inputs[${instrument}]}" || -z "${outputs[${instrument}]}" || -z "${bandwidth_in[${instrument}]}" || -z "${bandwidth_out[${instrument}]}" || -z "${channels[${instrument}]}" ]] ; then
      kcpmsg -l error "incomplete information for instrument ${instrument}"
      problem="${instrument}"
    else
      echo "#instrument-list ${instrument[${instrument}]} ${availability[${instrument}]} ${size[${instrument}]} ${inputs[${instrument}]} ${outputs[${instrument}]} ${bandwidth_in[${instrument}]} ${bandwidth_out[${instrument}]} ${channels[${instrument}]}"
    fi
  done

  if [ -n "${problem}" ] ; then
    echo "!instrument-list fail read-logs"
    return 1
  fi

  echo "!instrument-list ok"
}

function instrument_probe()
{
  shift

  if ! recheck_configs ; then
    echo "!instrument-probe fail read-logs"
    return 1
  fi

  compute_resources "$@"

  if [ "$?" -eq 0 ] ; then
    echo "!instrument-probe ok sufficient"
    return
  fi

  if [ "$?" -eq 2 ] ; then
    echo "!instrument-probe ok oversubscribed"
    return
  fi

  echo "!instrument-probe fail"
}

### halt ###

function cmc_halt()
{
  shift

  if kcprun -j sudo shutdown -h now ; then
    echo "!cmc-halt ok"
  else
    echo "!cmc-halt fail"
  fi
}

#################################################

source cmc-lib.sh
source cmc-resource.sh
source cmc-instrument.sh

inhibit_logging
enable_misc_informs
register_commands primary

#################################################

reload_resource_exclusions

init_multicast
init_resources

reload_instruments

check_resources

#################################################

main_loop
