#!/bin/bash

# internal ... 
declare -a command_vector

# static lookup up: [N]=name
declare -a instruments_deployed
# [name]=resources_needed
declare -A instruments_sizes
# [name]=stream1:stream2:...
declare -A instruments_streams

# [array_name]=input1-input2-input2-...
declare -A subarray_list

# [board]=status
declare -A resource_set
# [board]=subarray
declare -A resource_use

export KATCP_LABEL=cmc-primary

if [ -n "${CMC_CONFIG}" ] ; then
  source "${CMC_CONFIG}"
else
  kcpmsg "running standalone"
  source ../misc/cmc.conf
fi

leases=/var/lib/misc/dnsmasq.leases
if [ ! -f ${leases} ] ; then
  if [ "${state}" = "production" ] ; then
    kcpmsg -l fatal "unable to locate a leases file"
  else
    leases=../stub/dnsmasq.leases
  fi
fi

# support functions 

function load_roaches()
{
  unset tmp_set
  declare -A tmp_set

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    tmp_set[$board]=standby

    if [ -z  "${resource_set[${board}]}" ] ; then
      resource_set[$board]=standby
    fi

  done

  for board in ${!resource_set[*]} ; do
    if [ -z "${tmp_set[${board}]}" ] ; then
      unset resource_set[$board]
    fi
  done
}

function static_checks()
{

  # Resource hardcoded currently, in future:
  # TODO: work out what roaches we have, maybe from hosts
  #resource_set=([R0]=standby [R1]=standby [R2]=standby [R3]=standby)

  load_roaches

  # instrument parameters hardcoded, work out from template in future
  instruments_sizes[rts]=2
  instruments_streams[rts]="X:Y"

  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    # TODO: calculate boards required from template, put it size
    # TODO: work out the data stream names, put it in streams
    # TOOD: work out resources, add them to set ? 
  done

}

function dynamic_checks()
{
  result=0

  unset resource_use

# TODO: more checking could be done, in particular retrieve list of active groups

  for array in ${subarray_list[*]} ; do 
    for file in ${CORR_DIR}/${array}-* ; do
      if [ -f ${file} ] ; then
        for board in $(grep '^ *servers_' $file | cut -f2 -d= | tr -s , ' ' ) ; do
          # TODO: check if it is in resources

          if [ -n "${resource_use[${board}]}" ] ; then
            kcpmsg -l fatal "resource ${board} allocated twice to ${resource_use[${board}]} and ${array}"
            result=1
          fi

          resource_use+=([${board}]=${array})

          if [ -z "${resource_set[${board}]}" ] ; then
            kcpmsg -l warn "unknown resource ${board} used in array ${array}"
            resource_set+=([${board}]="up"):
          fi

          if [ "${resource_set[${board}]}" != "up" ] ; then
            kcpmsg -l warn "resource ${board} allocated to array ${array} despite not marked up"
            result=1
            resource_set[${board}]="up"
          fi

        done
      else
        kcpmsg -l warn "no corr config ${file} for ${array} found"
      fi
    done
  done

}

function lk_get_result()
{
  as=$2
  get=$1

  while read cmd code extra ; do 
    case "${cmd}" in 
      (\#${get})
        if [ -n "${as}" ] ; then
          echo "#${as} ${code} ${extra}"
        fi
        ;;
      (\!${get})
        if [ -n "${as}" ] ; then
          echo "!${as} ${code} ${extra}"
        fi
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          return 1
        fi
        ;;
    esac
  done

}

# primary functions

function array_list()
{
  shift

  echo ?listener-list $*
  while read cmd label port host ; do 
    case "${cmd}" in 
      (\#listener-list)
        compound=${subarray_list[$label]}
        if [ -n "${compound}" ] ; then
          if [ "${host}" = "0.0.0.0" ] ; then
            unset host
          fi
          echo "#array-list ${label} ${host}${host:+:}${port} ${compound//-/ }"
        fi
        ;;
      (\!listener-list)
        if [ "${port}" = "not-found" ] ; then
          echo "!array-list ${label} unknown-array"
        else
          echo "!array-list ${label}"
        fi
        return 
        ;;
    esac
  done
}

function array_assign()
{
  shift

  if [ "$#" -lt 3 ] ; then
    echo "insufficient parameters"
    return
  fi

  key=$1

  # TODO: should query the running listeners 
  if [ -n "${subarray_list[$key]}" ] ; then
    kcpmsg "array ${key} already in use"
    echo "!array-assign fail"
    return
  fi

  shift

  echo "?group-create $key"
  if ! lk_get_result group-create ; then
    echo "!array-assign fail"
    return
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port}
    kcpmsg -l info "using hardcoded port ${port} for rts array"
  else
    port=0
    kcpmsg -l info "will select a free port for array other than rts"
  fi

  echo "?listener-create ${key} ${port} 0.0.0.0"
  if ! lk_get_result listener-create ; then
    echo "?group-halt ${key}"
    echo "!array-assign fail"
    return
  fi

# TODO - retrieve port number for return code

  echo "?client-exec subordinate ${key} cmc-subordinate ${key} $*"
  if ! lk_get_result client-exec ; then
    echo "?group-halt ${key}"
    echo "!array-assign fail"
    return
  fi

  unset t

  while [ -n "$1" ] ; do
    t=${t}${t:+-}${1}
    shift
  done

  subarray_list[$key]=$t

  echo "!array-assign ok"
}

function array_halt()
{
  shift

  key=$1

  if [ -z "${key}" ] ; then
    kcpmsg "need a subarray to destroy"
    echo "!array-halt fail"
    return
  fi

  if [ -z "${subarray_list[$key]}" ] ; then
    kcpmsg "no state available for array ${key}"
    echo "!array-halt fail unknown-array"
    return
  fi

  echo "my state for $key is ${subarray_list[$key]}"

  unset subarray_list[$key]

  for board in ${!resource_use[*]} ; do
    if [ "${resource_use[${board}]}" = "$key" ] ; then
      unset resource_use[${board}]
    fi
  done

  echo "?group-halt ${key}"

  lk_get_result group-halt array-halt
}

function resource_list()
{
  shift

  # TODO: invoke dynamic_checks

  if [ -n "$1" ] ; then

    if [ -z "${resource_set[$1]}" ] ; then
      kcpmsg "resource $1 not found"
      echo "!resource-list fail"
      return 1
    fi

    echo "#resource-list $1 ${resource_set[$1]} ${resource_use[$1]}"

  else

    for board in ${!resource_set[*]} ; do
      echo "#resource-list ${board} ${resource_set[${board}]} ${resource_use[${board}]}"
    done

    echo "!resource-list ok"

  fi
}

function resource_mark()
{
  shift

  if [ "$#" -lt 2 ] ; then
    kcpmsg "insufficient arguments"
    echo "!resource-mark fail"
    return 1
  fi

  if [ -z "${resource_set[$1]}" ] ; then
    kcpmsg "unknown resource ${1}"
    echo "!resource-mark fail"
    return
  fi

  case "${2}" in
    (up) 
      if ping -W 2 -n -q -c 1 $1 >& /dev/null ; then
        resource_set[$1]="up"
      else
        if [ "${state}" = "production" ] ; then
          kcpmsg -l error "resource $1 unresponsive"
          resource_set[$1]="standby"
          echo "!resource-mark fail"
          return 1
        else
          kcpmsg -l warn "resource $1 not responsive but taking it to be ok"
          resource_set[$1]="up"
        fi
      fi
      ;;
    (standby) 
      if [ -n "${resource_use[$1]}" ] ; then
        kcpmsg "refusing to release resource $1 held by array ${resource_use[$1]}"
        echo "!resource-mark fail"
        return
      fi
      resource_set[$1]="standby"
      ;;
    (*) 
      kcpmsg "unknown marking ${2} for resource ${1}"
      echo "!resource-mark fail"
      return 1
      ;;
  esac

  echo "!resource-mark ok"
}

# subordinate requests

function instrument_list()
{
  shift

  for instrument in ${instruments_deployed[*]} ; do 
    t=${instruments_streams[${instrument}]}
    echo "#instrument-list ${instrument} ${t/:/ }"
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  shift

  if [ "$#" -lt 1 ] ; then
    kcpmsg "insufficient arguments"
    echo "!instrument-probe fail"
    return
  fi

  instrument=$1

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg "no information about instrument ${instrument} found"
    echo "!instrument-probe fail"
    return
  fi

  unset resource_free
  declare -a resource_free

  for board in ${!resource_set[*]} ; do
    if [ "${resource_set[${board}]}" = "up" -a -z "${resource_use[${board}]}" ] ; then
      resource_free+=(${board})
    fi
  done

  echo ${resource_free[*]}
  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg "would need ${need} boards but only have ${have}"
    echo "!instrument-probe ok oversubscribed"
    return
  fi

  kcpmsg "would allocate ${need} boards of ${have} available"

  echo "!instrument-probe ok"
}

function instrument_activate()
{
  shift

  if [ "$#" -lt 2 ] ; then
    kcpmsg "insufficient arguments (special case)"
    echo "!instrument-activate fail"
    return
  fi

  subarray=$1

  instrument=$2

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg "no information about instrument ${instrument} found"
    echo "!instrument-activate fail"
    return
  fi

  if [ -z "${subarray_list[${subarray}]}" ] ; then
    kcpmsg -l error "subarray ${subarray} does not seem to exist"
    echo "!instrument-activate fail"
    return
  fi

  unset resource_free
  declare -a resource_free

  for board in ${!resource_set[*]} ; do
    if [ "${resource_set[${board}]}" = "up" -a -z "${resource_use[${board}]}" ] ; then
      resource_free+=(${board})
    fi
  done

  #echo ${resource_free[*]}
  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg "would need ${need} boards but only have ${have}"
    echo "!instrument-activate ok oversubscribed"
    return 1
  fi

  i=0

  unset resource_grab
  declare -a resource_grab

  while [ "$i" -lt "${need}" ] ; do
    resource_grab[$i]=${resource_free[$i]}
    i=$[i+1]
  done

  compound=${subarray_list[$subarray]}

  kcpmsg "about to configure instrument ${instrument} for ${subarray} with ${resource_grab[*]} resources and inputs ${compound/-/ }"
  
  if ! cmc-config ${subarray} ${instrument} ${compound/-/ } ${resource_grab[*]} ; then
    kcpmsg "unable to generate config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail"
    return 1
  fi

  nextport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

  kcpmsg "selecting port ${nextport} for instrument ${instrument} of array ${subarray}"

  echo "?client-exec ${subarray}-${instrument} ${subarray} network-cmc-corr-stub" ${CORR_DIR}/${subarray}-${instrument} ${nextport}
  if ! lk_get_result client-exec ; then
    echo "!instrument-activate fail"
    return 1
  fi

  sleep 0.5

  echo "?client-connect localhost:${nextport} ${subarray}"
  if ! lk_get_result client-connect ; then
    echo "!instrument-activate fail"
    return 1
  fi

  echo "?client-rename corr localhost:${nextport}" 
  if ! lk_get_result client-rename ; then
    echo "!instrument-activate fail"
    return 1
  fi

  for board in ${resource_grab[*]} ; do
    resource_use[${board}]=${subarray}
  done

  echo "!instrument-activate ok"
}

# mainloop

static_checks

while read line ; do 

  i=0;
  rest=${line}
  while [ -n "${rest}" ] ; do
    command_vector[$i]=${rest%% *}
    update=${rest#* }
    if [ "${update}" = "${rest}" ] ; then
      rest=""
    else 
      rest=${update}
    fi
    i=$[i+1]
  done

  max=$i
  cmd=${command_vector[0]}

  case "${cmd}" in
    (\?array-list) 
      array_list ${command_vector[@]}
      ;;
    (\?array-assign) 
      array_assign ${command_vector[@]}
      ;;
    (\?array-halt) 
      array_halt ${command_vector[@]}
      ;;
    (\?resource-list) 
      resource_list ${command_vector[@]}
      ;;
    (\?resource-mark) 
      resource_mark ${command_vector[@]}
      ;;
    (\?instrument-list) 
      instrument_list ${command_vector[@]}
      ;;
    (\?instrument-probe) 
      instrument_probe ${command_vector[@]}
      ;;
    (\?instrument-activate) 
      instrument_activate ${command_vector[@]}
      ;;
    (*)
      if [ "${cmd:0:1}" = '?' ] ; then
        kcpmsg "cmc primary got unsupported request ${cmd}"
        echo "!${cmd:1} fail"
      fi
      ;;
  esac

  i=0
  while [ ${i} -lt ${max} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done
  
done
