#!/bin/bash

export KATCP_LABEL=cmc-resource

configuration=${CMC_CONFIG:-/etc/cmc.conf}

if [ -f "${configuration}" ] ; then
  source "${configuration}"

  if [ "${state/verbose-log/}" != "${state}" ] ; then
    set -x
  fi

  leases=${LEASE_FILE}

  if [ ! -f "${leases}" ] ; then
    kcpmsg -l fatal "no lease file to be found"
  fi

else
  kcpmsg -l fatal "unable to locate ${configuration} thus making things up"
  set -x

  if [ -f /var/lib/misc/dnsmasq.leases ] ; then
    leases=/var/lib/misc/dnsmasq.leases
  else
    leases=../tests/dnsmasq.leases
  fi
fi

### essential declarations ##############################

declare -a -r resource_types=(roach skarab)

# valid command names and their minimum parameter count 
declare -A -r command_set=([resource-reload]=1 [resource-list]=1 [resource-mark]=3 [subordinate-assign]=3 [subordinate-list]=1 [subordinate-halt]=2)

declare -a command_vector
declare -i command_size=0

### queue library #######################################

declare -a queue_data
declare -i queue_tail=0

function clear_queue()
{
  local i=0

  while [ "${i}" -lt "${queue_tail}" ] ; do
    unset queue_data[${i}]
    i=$[i+1]
  done

  queue_tail=0
}

function add_queue()
{
  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "no parameters"
    return 1
  fi

  queue_data[${queue_tail}]="$*"

  kcpmsg -l debug "queue[${queue_tail}]: $*"

  queue_tail=$[queue_tail+1]
}

function show_queue()
{
  local i

  kcpmsg -l debug "#### dump start ####"

  i=0
  while [ "${i}" -lt "${queue_tail}" ] ; do
    kcpmsg -l debug "queue[${i}]: ${queue_data[${i}]}"
    i=$[i+1]
  done

  kcpmsg -l debug "#### dump end ####"
}

### error stack #########################################

declare -a failure_stack
declare -i failure_depth=0

function push_failure()
{
  failure_depth=$[failure_depth+1]
  failure_stack[${failure_depth}]=0
}

# pop failure to be used in if statement where we return or we are no longer interested in error codes
# clear failure to be used in if statements where there is no return

function pop_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  if [ "${failure_depth}" -gt "0" ] ; then
    failure_depth=$[failure_depth-1]
  else
    kcpmsg -l warn "unwound stack too far"
  fi

  return ${result}
}

function clear_failure()
{
  result=${failure_stack[${failure_depth}]}

  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  failure_stack[${failure_depth}]=0

  return ${result}
}

function set_failure()
{
  failure_stack[${failure_depth}]=$[failure_stack[${failure_depth}]+1]
}

### transform line into vector ##########################

function make_vector()
{
  local i

  i=0
  while [ ${i} -lt ${command_size} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done

  command_size=0
  while [ $# -gt 0 ] ; do
    command_vector[${command_size}]=$1
    command_size=$[command_size+1]
    shift
  done

  kcpmsg -l debug "parsed ${command_size} parameters"
}

### io functions with failure stack #####################

send_count=0

function send_request()
{
  local name="$1"

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  if [ "${send_count}" -gt 0 ] ; then
    kcpmsg -l warn "sending ${send_count} request(s) without waiting for reply"
  fi

  send_count=$[send_count+1]

  echo "?$*"
}

function retrieve_reply()
{
  local name="$1"
  local line art reply code 
  local -a vector

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    elif [ "${art}" = "!" ] ; then
      vector=(${line})
      reply=${vector[0]}
      if [ "${reply:1}" = "${name}" ]; then
        send_count=$[send_count-1]
        code=${vector[1]}
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else
        kcpmsg -l warn "discarding unexpected response ${reply:1}"
      fi
    fi
  done
}

declare -A inform_result

function retrieve_inform()
{
  local name="$1"
  local match="$2"
  local del line label
  local -a vector

  for del in "${!inform_result[@]}" ; do
    unset inform_result[${del}]
  done

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#${name}" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${match}" = "${label}" ] ; then
          inform_result[${label}]="${line#* * }"
        fi
      elif [ "${vector[0]}" = "!${name}" ] ; then
        send_count=$[send_count-1]
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}

declare -A var_result

function fetch_var()
{
  local del line
  local -a vector

  for del in "${!var_result[@]}" ; do
    unset var_result[${del}]
  done

  if [ "$1" = '-a' ] ; then
    shift
    echo "?var-show"
  else
    echo "?var-show $1"
  fi

  match=$1

  while read line ; do 
    if [ "${line:0:1}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      if [ "${vector[0]}" = "#var-show" ] ; then
        label=${vector[1]}
        if [ -z "${match}" -o "${label}" != "${label#${match}}" ] ; then
          var_result[${label}]="${vector[2]}"
        fi
      elif [ "${vector[0]}" = "!var-show" ] ; then
        if [ "${vector[1]}" = "ok" ] ; then
          return 0
        else
          set_failure
          return 1
        fi 
      else 
        if [ "${line:0:1}" = "!" ] ; then
          kcpmsg -l warn "discarding unexpected response ${line:1}"
        fi
      fi
    fi
  done
}


### support functions ###################################

# resources:name:when       - last time we checked it 
# resources:name:status     - what the user status is
#
# resources:name:type       - what type of resource it is 
# resources:name:mode       - did the user decide its status
# resources:name:holder     - which subarray owns it

push_failure
send_request   var-declare  "resources*"  map,readonly
retrieve_reply var-declare

if ! pop_failure  ; then
  kcpmsg -l fatal "unable to declare essential resource tracking state"
  exit 1
fi

function check_resources()
{
  local -l board
  local now mode art status when fresh key tmp board

  now=$(date +%s)

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    push_failure

    fetch_var "resources:${board}"
    fresh=0

    if ! clear_failure ; then
      send_request   var-declare resources map    ":${board}"
      retrieve_reply var-declare

      send_request   var-set     resources roach  string ":${board}:type"
      retrieve_reply var-set

      send_request   var-set     resources auto   string ":${board}:mode"
      retrieve_reply var-set

      mode=auto
      art=roach
      when=${now}
      status=unknown

    else 
      fresh=1

      mode="${var_result[resources:${board}:mode]}"
      art="${var_result[resources:${board}:type]}"
      when="${var_result[resources:${board}:when]}"
      status="${var_result[resources:${board}:status]}"

      if [ "${mode}" == auto ] ; then 
        if [ "$[when+checkperiod]" -le "${now}" ] ; then
          fresh=0
          send_request   var-delete  "resources:${board}:when"
          retrieve_reply var-delete 
          send_request   var-delete  "resources:${board}:status"
          retrieve_reply var-delete
        fi
      fi
    fi

    kcpmsg "checked ${board} at ${when} with status now ${status}"

    if [ "${fresh}" = "0" ] ; then
      if kcpcmd -kir -f -t 2 -s "${board}" watchdog ; then
        status=up
      else 
        status=standby
      fi

      send_request   var-set      "resources" ${now}     string ":${board}:when"
      retrieve_reply var-set
      send_request   var-set      "resources" ${status}  string ":${board}:status"
      retrieve_reply var-set
    fi

    if ! pop_failure  ; then
      kcpmsg -l fatal "unable to update status of board ${board}"
      return 1
    fi

  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to retrieve resource variables"
    return 1
  fi

  push_failure

  for key in "${!var_result[@]}" ; do
    if [ "${key##*:}" = "when" ] ; then
      when="${var_result[${key}]}"
      if [ "$[when+checkperiod]" -le "${now}" ] ; then
        tmp="${key#resources:}"
        board="${tmp%%:*}"
        if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
          if [ "${var_result[resources:${board}:status]}" = "up" ] ; then
            if [ "${var_result[resources:${board}:mode]}" = "auto" ] ; then
              if ! kcpcmd -kir -f -t 1 -s "${board}" watchdog >& /dev/null ; then
                send_request   var-set      "resources" standby string ":${board}:status"
                retrieve_reply var-set
              fi
            fi
          fi
        fi
      fi
    fi
  done

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to update expired resource"
    return 1
  fi

  return 0
}

### api functions ### resources #########################

function resource_reload()
{
  if check_resources ; then
    echo "!resource-reload ok"
  else
    echo "!resource-reload fail"
  fi
}

function resource_list()
{
  local key board tmp
  local -A vector

  check_resources 

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l error "unable to retrieve resource variables"
    echo "!resource-list fail"
  fi

  for key in "${!var_result[@]}" ; do
    tmp="${key#resources:}"
    board="${tmp%%:*}"

    vector[${board}]="#resource-list ${board} ${var_result[resources:${board}:status]} ${var_result[resources:${board}:holder]}"
  done

  for key in "${vector[@]}" ; do 
    echo "$key"
  done

  echo "!resource-list ok"
}

function resource_mark()
{
  local board status 

  shift 
  
  board=$1
  status=$2

  check_resources

  push_failure

  fetch_var "resources:${board}"

  if ! pop_failure  ; then
    kcpmsg -l error "unable to retrieve resource ${board}"
    echo "!resource-mark fail unknown-item"
    return 1
  fi

  case "${status}" in
    (up) 
      if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
        if ! kcpcmd -k -r -i -s "${board}" watchdog >& /dev/null ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l error "resource ${board} unresponsive"
            echo "!resource-mark fail network"
            return 1
          fi
          kcpmsg -l warn "roach resource ${board} not responsive but taking it to be ok"
        fi
      fi

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "up" ] ; then
        send_request   var-set  "resources" up     string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (standby)

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
        send_request   var-set  "resources" standby  string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (reset)

      if [ "${var_result[resources:${board}:type]}" != roach ] ; then
        kcpmsg -l warn "no way of resetting resource ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      if [ -n "${var_result[resources:${board}:holder]}" ] ; then
        kcpmsg -l warn "unwilling to reset resource ${board} as it is used by ${var_result[resources:${board}:holder]}"
        echo "!resource-mark fail in-use"
        return 1
      fi

      push_failure

      send_request   var-set  "resources" standby  string ":${board}:status"
      retrieve_reply var-set

      if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
        send_request   var-set  "resources" auto   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      if ! kcpcmd -k -i -r -s "$1" restart ; then
        kcpmsg -l error "unable to restart resource ${board}"
        echo "!resource-mark fail network"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (*) 
      kcpmsg -l error "unknown marking ${status} for resource ${board}"
      echo "!resource-mark fail usage"
      return 1
    ;;
  esac
}

### api functions ### subordinates ######################

function subordinate_list()
{
  local -A ports hosts groups
  local -a v 
  local group port host key
  local c t

  shift

  push_failure

  send_request    listener-list "$*"
  retrieve_inform listener-list

  if ! pop_failure ; then
    echo "!subordinate-list fail"
    return 1
  fi

# WARNING: we assume one listener per group here 

  kcpmsg -l debug "my keys are ${!inform_result[@]}" 
  for key in "${!inform_result[@]}" ; do
    v=(${inform_result[${key}]})
    if [ -z "${v[2]}" ] ; then
      group="${key}"
    else
      group=${v[2]}
    fi
    
    ports[${key}]=${v[0]}
    hosts[${key}]=${v[1]}
    groups[${key}]=${group}

  done

  push_failure

  c=0
  for key in "${!groups[@]}" ; do

    group="${groups[${key}]}"

    fetch_var  "${group}*subordinate*"

    if clear_failure ; then 

      subarray="${var_result[${group}*subordinate*]}"

      if [ -n "${subarray}" ] ; then

        if [ "${key}" != "${subarray}" ] ; then
          kcpmsg -l warn "possible consistency issue where listener label ${key} does not match subarray name ${subarray}"
        fi

        port=${ports[${group}]}
        host=${hosts[${group}]}

        kcpmsg -l debug "considering ${group} with listener ${host}:${port}"


        if [ "${host}" = "0.0.0.0" ] ; then
          unset host
        fi 

        fetch_var "${group}*inputs*"

        if clear_failure ; then
          echo "#subordinate-list "${subarray}" ${host}${host:+:}${port} ${var_result[*]}"
          c=$[c+1]
        fi

      fi

    fi
  done

  pop_failure

  if [ "${c}" -lt "$#"  ] ; then
    kcpmsg -l debug "was given $# parameters, could only list ${c} subarrays"
    echo "!subordinate-list fail unknown-array"
    return 1
  fi

  echo "!subordinate-list ok"
  return 0
}

function subordinate_assign()
{
  local port key prefix group file
  local i t

  shift

  key=$1
  
# TODO: process key into group name via prefix

  group=${key}
  
  push_failure

  send_request   group-list "${group}"
  retrieve_reply group-list

  if pop_failure ; then
    kcpmsg -l warn "array ${group} already in use"
    echo "!subordinate-assign fail already-exists"
    return 1
  fi

#   for instrument in ${instruments_deployed[*]} ; do
#     if [ ${instruments_inputs[${instrument}]} = "$#" ] ; then
#       match=$[match+1]
#     fi
#   done
# 
#   if [ "${match}" -le "0" ] ; then
#     kcpmsg -l error "no instruments available for a subarray of $# inputs"
#     echo "!subordinate-assign fail unsupported-size"
#     return
#   fi
# 
#   kcpmsg -l info "have ${match} instruments on offer for a subarray of $# inputs"

  if [ -n "${CORR_DIR}" ] ; then
    for file in ${CORR_DIR}/${key}-* ; do
      if [ -f ${file} ] ; then
        if rm ${file} ; then
          kcpmsg -l debug "removing old config ${file}"
        else 
          kcpmsg -l error "unable to remove old config file ${file}"
#        echo "!subordinate-assign fail read-logs"
#        return
        fi
      fi
    done
  fi

  push_failure

  send_request   group-create "${group}"
  retrieve_reply group-create

  if ! pop_failure ; then
    kcpmsg -l warn "unable to create group ${group} for array"
    echo "!subordinate-assign fail read-logs"
    return 1
  fi

# TODO: a prune_holder here, to clean out stale resources 

# WARNING: we have created the group - now committed to deleting it on failure ... 

  push_failure

  send_request   var-declare "${group}*subordinate*" string
  retrieve_reply var-declare 

  send_request   var-set "${group}*subordinate*" "$key" string 
  retrieve_reply var-set

  send_request   var-declare "${group}*inputs*" array
  retrieve_reply var-declare 

  shift 
  i=0

  while [ "$#" -ge 1 ] ; do
    send_request   var-set "${group}*inputs*" "$1" string "#$i"
    retrieve_reply var-set

    shift
    i=$[i+1]
  done

  if ! clear_failure ; then

    send_request   group-halt "${group}"
    retrieve_reply group-halt
    
    pop_failure

    kcpmsg -l warn "unable to record inputs for group ${group}"
    echo "!subordinate-assign fail read-logs"
    return 1
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port:-7404}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    t="${key//[^0-9]/}"
    if [ "$t" -gt 0 ] ; then
      port=$[base_port+t]
      if [ "$port" -gt "${base_port}" ] ; then
        kcpmsg "selecting name derived port ${port}"
      else
        kcpmsg -l warn "malformed port ${port} thus falling back to automatic selection"
        port=0
      fi
    else 
      kcpmsg "will select a free port for array other than rts"
      port=0
    fi
  fi

  push_failure

  send_request   listener-create "${key}" "${port}" "0.0.0.0" "${group}"
  retrieve_reply listener-create

  if [ "${port}" -le "0" ] ; then
    send_request listener-list "${key}" 
    retrieve_inform listener-list "${key}"
    port=${inform_result[${key}]%% *}
    if [ "${port}" -le "0" ] ; then
      kcpmsg -l error "unable to determine port for ${key} - got ${result}"
      set_failure
    fi
  fi 

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start listener for group ${group}"
    echo "!subordinate-assign fail network"
    return 1
  fi

  send_request   client-exec subordinate ${key} cmc-subordinate ${key} $*
  retrieve_reply client-exec

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start control task for group ${group}"
    echo "!subordinate-assign fail task-start"
    return 1
  fi

  pop_failure

#  make_subarray_sensors ${key}

  echo "!subordinate-assign ok ${port}"
  return 0
}

function subordinate_halt()
{
  local group key

  shift

  key="$1"

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!subordinate-halt fail usage"
    return 1
  fi

  group="${key}"

  push_failure

  fetch_var "${group}*subordinate*"

  if ! pop_failure ; then
    kcpmsg -l error "could not locate variable suborinate in group ${group}"

    kcpmsg -l error "subarray ${key} not found and so not halted"

    echo "!subordinate-halt fail unknown-item"
    return 1
  fi

  push_failure

  send_request    group-halt "$key"
  retrieve_reply  group-halt

  if ! pop_failure ; then
    echo "!subordinate-halt fail read-logs"
    return 1
  fi

  echo "!subordinate-halt ok"
  return 0
}

### main loop ###########################################

push_failure
send_request   client-config info-all
retrieve_reply client-config
send_request   log-limit off
retrieve_reply log-limit
pop_failure  

while read line ; do 
  add_queue ${line}
  show_queue

  k=0
  while [ "${k}" -lt "${queue_tail}" ] ; do

    string=${queue_data[${k}]}
    k=$[k+1]

    if [ "${string:0:1}" = "?" ] ; then

      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -z "${command_set[${cmd}]}" ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd} fail unknown-item"
      else
        if [ "${command_size}" -lt "${command_set[${cmd}]}" ] ; then
          kcpmsg -l warn "need at least ${command_set[${cmd}]} parameters for ${cmd} but saw only ${command_size}"
          echo "!${cmd} fail usage"
        else
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi 
      fi

    fi

  done

  clear_queue
  
done
