#!/bin/bash

# internal ... 
declare -a command_vector

# static lookup up: [N]=name
declare -a instruments_deployed
# [name]=resources_needed
declare -A instruments_sizes
# [name]=stream1:stream2:...
declare -A instruments_streams

# [array_name]=input1-input2-input2-...
declare -A subarray_list

# [board]=status
declare -A resource_set
# [board]=subarray
declare -A resource_use
# [N]=board
declare -a resource_free

export KATCP_LABEL=cmc-primary

if [ -n "${CMC_CONFIG}" ] ; then
  source "${CMC_CONFIG}"
else
  kcpmsg "running standalone"
  source ../misc/cmc.conf
fi

leases=/var/lib/misc/dnsmasq.leases
if [ ! -f ${leases} ] ; then
  if [ "${state}" = "production" ] ; then
    kcpmsg -l fatal "unable to locate a leases file"
  else
    leases=../stub/dnsmasq.leases
  fi
fi

#################################################################################
# checking functions

function validate_subarray_list()
{
  unset valid_list
  declare -A valid_list

  echo ?group-list 
  while read cmd group extra ; do 
    case "${cmd}" in 
      (\#group-list)
        valid_list[${group}]=valid
        ;;
      (\!group-list)
        if [ "${group}" != "ok" ] ; then
          kcpmsg -l error "unable to work out subarray set (status ${group})"
          return 1
        fi

        kcpmsg -l debug "found groups ${!valid_list[*]}"

        for array in ${!subarray_list[@]} ; do
          if [ "${valid_list[${array}]}" != "valid" ] ; then
            kcpmsg "relasing subarray ${array}"
            unset subarray_list[${array}]
          fi
        done

        return 0
        ;;
    esac
  done
}

function validate_resource_free()
{
  resource_free=()

  for board in ${!resource_set[*]} ; do
    if [ "${resource_set[${board}]}" = "up" -a -z "${resource_use[${board}]}" ] ; then
      resource_free+=(${board})
    fi
  done

  kcpmsg -l debug "${#resource_free[*]} boards are available for allocation"
}

function validate_resource_use()
{
  result=0

  resource_use=()

  for array in ${!subarray_list[*]} ; do 

    kcpmsg "checking array ${array}"

    for file in ${CORR_DIR}/${array}-* ; do
      if [ -f ${file} ] ; then

        kcpmsg -l debug "checking config ${file}"

        for board in $(grep '^ *hosts' ${file} | cut -f2 -d= | tr -s , ' ' ) ; do

          if [ -n "${resource_use[${board}]}" ] ; then
            kcpmsg -l fatal "resource ${board} allocated twice to ${resource_use[${board}]} and ${array}"
            result=1
          fi

          if [ -z "${resource_set[${board}]}" ] ; then
            kcpmsg -l warn "unknown resource ${board} used in array ${array}, ignoring it"
          else 
            resource_use[${board}]=${array}

            kcpmsg "confirming that ${board} is used by ${array}"

            if [ "${resource_set[${board}]}" != "up" ] ; then
              kcpmsg -l warn "resource ${board} allocated to array ${array}, despite not marked up"
              result=1
            fi
          fi
        done
      fi
    done
  done

  return ${result}
}


function validate_resource_set()
{
  unset tmp_set
  declare -A tmp_set

  # policy decision: we only ping very new or very stale boards, 
  # real monitoring needs to be done elsewhere, in any event 
  # we should never transition from standby->up automatically
  # (other than startup) as this may make board replacement problematic

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    tmp_set[$board]=standby

    if [ -z "${resource_set[${board}]}" ] ; then
      if ping -W 2 -n -q -c 1 ${board} >& /dev/null ; then
        resource_set[${board}]=up
      else 
        resource_set[${board}]=standby
      fi
      # TODO: launch the matching sensor monitor
    fi

  done

  # if old board, not in dhcp. not used, marked standby and unpingable, forget it

  for board in ${!resource_set[*]} ; do
    if [ -z "${tmp_set[${board}]}" ] ; then
      if [ -z "${resource_use[${board}]}" ] ; then
        if [ "${resource_set[${board}]}" = "standby" ] ; then
          if ! ping -W 2 -n -q -c 1 ${board} >& /dev/null ; then
            if [ "${state}" = "production" ] ; then
              kcpmsg -l warn "dropping resource ${board} as unreachable, unregistered, unused and inactive"
              unset resource_set[$board]
              # TODO: stop the matching sensor monitor
            fi 
          fi 
        fi
      fi
    fi
  done
}

function validate_instruments()
{
  # TODO: split into validate*size and validata*stream ? 

  if [ "${#instruments_deployed[@]}" -le 0 ] ; then
    kcpmsg -l fatal "no instruments deployed"
    return
  fi

  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    if [ -f ${template} ] ; then

      top=$(cat $template  | tr ',=' '\n' | grep ROACH[0-9] | sort -n | tail -1 | tr -dc [0-9])

      if [ -z "${top}" ] ; then
        kcpmsg -l fatal "unable to determine resource requirements for instrument ${instrument}"
      else 
        instruments_sizes[${instrument}]=$[top+1]

        kcpmsg "instrument ${instrument} requires ${instruments_sizes[${instrument}]} resources"
      fi

      # instrument parameters hardcoded, work out from template in future
      # TODO: work out the data stream names, put it in streams
      instruments_streams[c8n856M4k]="X:Y"

    else
      kcpmsg -l fatal "no template available for instrument ${instrument}"
    fi

  done

}

#################################################################################
# misc

function lk_get_result()
{
  as=$2
  get=$1

  while read cmd code extra ; do 
    case "${cmd}" in 
      (\#${get})
        if [ -n "${as}" ] ; then
          echo "#${as} ${code} ${extra}"
        fi
        ;;
      (\!${get})
        if [ -n "${as}" ] ; then
          echo "!${as} ${code} ${extra}"
        fi
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          return 1
        fi
        ;;
    esac
  done

}

function make_sensors()
{
  echo "?var-declare ${1}*device-status* sensor,map"
  lk_get_result var-declare

  echo "?var-set ${1}*device-status* ok string :value"
  lk_get_result var-set
  echo "?var-set ${1}*device-status* ${1:-system}\_health string :help"
  lk_get_result var-set
  echo "?var-set ${1}*device-status* nominal string :status"
  lk_get_result var-set
  echo "?var-set ${1}*device-status* discrete string :type"
  lk_get_result var-set

  echo "?var-set ${1}*device-status* ok       string :range#0"
  lk_get_result var-set
  echo "?var-set ${1}*device-status* degraded string :range#1"
  lk_get_result var-set
  echo "?var-set ${1}*device-status* fail     string :range#2"
  lk_get_result var-set
}

#################################################################################
# primary requests 

function array_list()
{
  shift

  echo ?listener-list $*
  while read cmd label port host ; do 
    case "${cmd}" in 
      (\#listener-list)
        compound=${subarray_list[$label]}
        if [ -n "${compound}" ] ; then
          if [ "${host}" = "0.0.0.0" ] ; then
            unset host
          fi
          echo "#array-list ${label} ${host}${host:+:}${port} ${compound//-/ }"
        fi
        ;;
      (\!listener-list)
        if [ "${port}" = "not-found" ] ; then
          echo "!array-list ${label} unknown-array"
        else
          echo "!array-list ${label}"
        fi
        return 
        ;;
    esac
  done
}

function array_assign()
{
  shift

  if [ "$#" -lt 3 ] ; then
    kcpmsg "insufficient parameters"
    echo "!array-assign fail"
    return
  fi

  validate_subarray_list

  key=$1

  if [ -n "${subarray_list[$key]}" ] ; then
    kcpmsg "array ${key} already in use"
    echo "!array-assign fail"
    return
  fi

  for file in ${CORR_DIR}/${key}-* ; do
    if [ -f ${file} ] ; then
      if rm ${file} ; then
        kcpmsg -l debug "removing old config ${file}"
      else 
        kcpmsg -l error "unable to remove old config file ${file}"
        echo "!array-assign fail"
        return
      fi
    fi
  done

  shift

  echo "?group-create $key"
  if ! lk_get_result group-create ; then
    echo "!array-assign fail"
    return
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    port=0
    kcpmsg "will select a free port for array other than rts"
  fi

  echo "?listener-create ${key} ${port} 0.0.0.0"
  if ! lk_get_result listener-create ; then
    echo "?group-halt ${key}"
    echo "!array-assign fail"
    return
  fi

# TODO - retrieve port number for return code

  echo "?client-exec subordinate ${key} cmc-subordinate ${key} $*"
  if ! lk_get_result client-exec ; then
    echo "?group-halt ${key}"
    echo "!array-assign fail"
    return
  fi

  unset t

  while [ -n "$1" ] ; do
    t=${t}${t:+-}${1}
    shift
  done

  subarray_list[$key]=$t

  make_sensors ${key}

  echo "!array-assign ok ${port}"
}

function array_halt()
{
  shift

  key=$1

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!array-halt fail"
    return
  fi

  validate_subarray_list

  if [ -z "${subarray_list[$key]}" ] ; then
    kcpmsg -l error "no state available for array ${key}"
    echo "!array-halt fail unknown-array"
    return
  fi

  kcpmsg "my state for $key is ${subarray_list[$key]}"

  unset subarray_list[$key]

  for board in ${!resource_use[*]} ; do
    if [ "${resource_use[${board}]}" = "$key" ] ; then
      unset resource_use[${board}]
    fi
  done

  echo "?group-halt ${key}"

  lk_get_result group-halt array-halt
}

function resource_list()
{
  shift

  validate_subarray_list
  validate_resource_set
  validate_resource_use

  if [ -n "$1" ] ; then

    if [ -z "${resource_set[$1]}" ] ; then
      kcpmsg -l error "resource $1 not found"
      echo "!resource-list fail"
      return 1
    fi

    echo "#resource-list $1 ${resource_set[$1]} ${resource_use[$1]}"

  else

    for board in ${!resource_set[*]} ; do
      echo "#resource-list ${board} ${resource_set[${board}]} ${resource_use[${board}]}"
    done

  fi

  echo "!resource-list ok"
}

function resource_mark()
{
  shift

  if [ "$#" -lt 2 ] ; then
    kcpmsg -l error "insufficient arguments"
    echo "!resource-mark fail"
    return 1
  fi

  if [ -z "${resource_set[$1]}" ] ; then
    kcpmsg -l error "unknown resource ${1}"
    echo "!resource-mark fail"
    return 1
  fi

  case "${2}" in
    (up) 
      if ping -W 2 -n -q -c 1 $1 >& /dev/null ; then
        resource_set[$1]="up"
      else
        if [ "${state}" = "production" ] ; then
          kcpmsg -l error "resource $1 unresponsive"
          resource_set[$1]="standby"
          echo "!resource-mark fail"
          return 1
        else
          kcpmsg -l warn "resource $1 not responsive but taking it to be ok"
          resource_set[$1]="up"
        fi
      fi
      ;;
    (standby) 
      if [ -n "${resource_use[$1]}" ] ; then
        kcpmsg -l error "refusing to release resource $1 held by array ${resource_use[$1]}"
        echo "!resource-mark fail"
        return
      fi
      resource_set[$1]="standby"
      ;;
    (*) 
      kcpmsg -l error "unknown marking ${2} for resource ${1}"
      echo "!resource-mark fail"
      return 1
      ;;
  esac

  echo "!resource-mark ok"
}

#################################################################################
# subordinate requests

function instrument_list()
{
  shift

  for instrument in ${instruments_deployed[*]} ; do 
    t=${instruments_streams[${instrument}]}
    echo "#instrument-list ${instrument} ${t/:/ }"
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  shift

  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "insufficient arguments"
    echo "!instrument-probe fail"
    return
  fi

  instrument=$1

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg -l error "no information about instrument ${instrument} found"
    echo "!instrument-probe fail"
    return
  fi

  validate_subarray_list
  validate_resource_set
  validate_resource_use
  validate_resource_free

  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg -l warn "would need ${need} boards but only have ${have}"
    echo "!instrument-probe ok oversubscribed"
    return
  fi

  kcpmsg "would allocate ${need} boards of ${have} available"

  echo "!instrument-probe ok"
}

function instrument_activate()
{
  shift

  if [ "$#" -lt 2 ] ; then
    kcpmsg -l error "insufficient arguments (special case)"
    echo "!instrument-activate fail"
    return
  fi

  subarray=$1
  instrument=$2

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg -l error "no information about instrument ${instrument} found"
    echo "!instrument-activate fail"
    return
  fi

  validate_subarray_list
  validate_resource_set
  validate_resource_use
  validate_resource_free

  if [ -z "${subarray_list[${subarray}]}" ] ; then
    kcpmsg -l error "subarray ${subarray} does not seem to exist"
    echo "!instrument-activate fail"
    return
  fi

  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg -l warn "would need ${need} boards but only have ${have}"
    echo "!instrument-activate ok oversubscribed"
    return 1
  fi

  i=0

  unset resource_grab
  declare -a resource_grab

  while [ "$i" -lt "${need}" ] ; do
    resource_grab[$i]=${resource_free[$i]}
    i=$[i+1]
  done

  compound=${subarray_list[$subarray]}

  kcpmsg "about to configure instrument ${instrument} for ${subarray} with ${resource_grab[*]} resources and inputs ${compound/-/ }"
  
  nextport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

  kcpmsg "selecting port ${nextport} for instrument ${instrument} of array ${subarray}"

  if ! cmc-config ${subarray} ${instrument} ${nextport} ${compound/-/ } ${resource_grab[*]} ; then
    kcpmsg -l error "unable to generate config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail"
    return 1
  fi

  echo "?client-exec ${subarray}-${instrument} ${subarray} corr2_servlet.py -p ${nextport}"
  if ! lk_get_result client-exec ; then
    echo "!instrument-activate fail"
    return 1
  fi

  sleep 2

  if kcpcmd -r -s localhost:${nextport} create ${CORR_DIR}/${subarray}-${instrument} ; then 
    kcpmsg -l error "unable load config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail"
    return 1
  fi

  echo "?client-connect localhost:${nextport} ${subarray}"
  if ! lk_get_result client-connect ; then
    echo "!instrument-activate fail"
    # TODO: kill the corr instance to release resources
    return 1
  fi

  echo "?client-rename corr localhost:${nextport}" 
  if ! lk_get_result client-rename ; then
    # TODO: kill the corr instance to release resources
    echo "!instrument-activate fail"
    return 1
  fi

  for board in ${resource_grab[*]} ; do
    kcpmsg "assigning resource ${board} to ${subarray}"
    resource_use[${board}]=${subarray}
  done

  kcpmsg -l warn "waiting for arp to stabilise ... patience"
  sleep 200

  echo "!instrument-activate ok"
}

#################################################################################
# mainloop

validate_instruments
validate_resource_set

while read line ; do 

  i=0;
  rest=${line}
  while [ -n "${rest}" ] ; do
    command_vector[$i]=${rest%% *}
    update=${rest#* }
    if [ "${update}" = "${rest}" ] ; then
      rest=""
    else 
      rest=${update}
    fi
    i=$[i+1]
  done

  max=$i
  cmd=${command_vector[0]}

  case "${cmd}" in
    (\?array-list) 
      array_list ${command_vector[@]}
      ;;
    (\?array-assign) 
      array_assign ${command_vector[@]}
      ;;
    (\?array-halt) 
      array_halt ${command_vector[@]}
      ;;
    (\?resource-list) 
      resource_list ${command_vector[@]}
      ;;
    (\?resource-mark) 
      resource_mark ${command_vector[@]}
      ;;
    (\?instrument-list) 
      instrument_list ${command_vector[@]}
      ;;
    (\?instrument-probe) 
      instrument_probe ${command_vector[@]}
      ;;
    (\?instrument-activate) 
      instrument_activate ${command_vector[@]}
      ;;
    (*)
      if [ "${cmd:0:1}" = '?' ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd:1} fail"
      fi
      ;;
  esac

  i=0
  while [ ${i} -lt ${max} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done
  
done
