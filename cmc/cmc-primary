#!/bin/bash

# internal ... 
declare -a command_vector

# static lookup up: [N]=name
declare -a instruments_deployed

# [name]=resources_needed
declare -A instruments_sizes

# [name]=inputs_needed
declare -A instruments_inputs

# [name]=stream1:stream2:...
declare -A instruments_streams

# [array_name]=input1-input2-input2-...
declare -A subarray_list

# [board]=status
declare -A resource_set
# [board]=subarray
declare -A resource_use
# [N]=board
declare -a resource_free

export KATCP_LABEL=cmc-primary

if [ -n "${CMC_CONFIG}" ] ; then
  source "${CMC_CONFIG}"
else
  kcpmsg "running standalone"
  source ../misc/cmc.conf
fi

leases=${LEASE_FILE:-/var/lib/misc/dnsmasq.leases}
if [ ! -f ${leases} ] ; then
  if [ "${state/missing-roaches/}" != "${state}" ] ; then
    leases=../stub/dnsmasq.leases
  else
    kcpmsg -l fatal "unable to locate leases file ${LEASE_FILE}"
  fi
fi

if [ "${state/verbose-log/}" != "${state}" ] ; then
    set -x
fi

#################################################################################
# checking functions

function validate_subarray_list()
{
  unset valid_list
  declare -A valid_list

  echo ?group-list 
  while read cmd group extra ; do 
    case "${cmd}" in 
      (\#group-list)
        valid_list[${group}]=valid
        ;;
      (\!group-list)
        if [ "${group}" != "ok" ] ; then
          kcpmsg -l error "unable to work out subarray set (status ${group})"
          return 1
        fi

        kcpmsg -l debug "found groups ${!valid_list[*]}"

        for array in ${!subarray_list[@]} ; do
          if [ "${valid_list[${array}]}" != "valid" ] ; then
            kcpmsg "relasing subarray ${array}"
            unset subarray_list[${array}]
          fi
        done

        return 0
        ;;
    esac
  done
}

function validate_resource_free()
{
  resource_free=()

  for board in ${!resource_set[*]} ; do
    if [ "${resource_set[${board}]}" = "up" -a -z "${resource_use[${board}]}" ] ; then
      resource_free+=(${board})
    fi
  done

  kcpmsg -l debug "${#resource_free[*]} boards are available for allocation"
}

function validate_resource_use()
{
  result=0

  resource_use=()

  for array in ${!subarray_list[*]} ; do 

    kcpmsg "checking array ${array}"

    for file in ${CORR_DIR}/${array}-* ; do
      if [ -f ${file} ] ; then

        kcpmsg -l debug "checking config ${file}"

        for board in $(grep '^ *hosts' ${file} | cut -f2 -d= | tr -s , ' ' ) ; do

          if [ -n "${resource_use[${board}]}" ] ; then
            kcpmsg -l fatal "resource ${board} allocated twice to ${resource_use[${board}]} and ${array}"
            result=1
          fi

          if [ -z "${resource_set[${board}]}" ] ; then
            kcpmsg -l warn "unknown resource ${board} used in array ${array}, ignoring it"
          else 
            resource_use[${board}]=${array}

            kcpmsg "confirming that ${board} is used by ${array}"

            if [ "${resource_set[${board}]}" != "up" ] ; then
              kcpmsg -l warn "resource ${board} allocated to array ${array}, despite not marked up"
              result=1
            fi
          fi
        done
      fi
    done
  done

  return ${result}
}


function validate_resource_set()
{
  unset tmp_set
  declare -A tmp_set

  # policy decision: we only ping very new or very stale boards, 
  # real monitoring needs to be done elsewhere, in any event 
  # we should never transition from standby->up automatically
  # (other than startup) as this may make board replacement problematic

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    tmp_set[$board]=standby

    if [ -z "${resource_set[${board}]}" ] ; then
      if ping -W 2 -n -q -c 1 ${board} >& /dev/null ; then
        resource_set[${board}]=up
      else 
        resource_set[${board}]=standby
      fi
      # TODO: launch the matching sensor monitor
    fi

  done

  # if old board, not in dhcp. not used, marked standby and unpingable, forget it

  for board in ${!resource_set[*]} ; do
    if [ -z "${tmp_set[${board}]}" ] ; then
      if [ -z "${resource_use[${board}]}" ] ; then
        if [ "${resource_set[${board}]}" = "standby" ] ; then
          if ! ping -W 2 -n -q -c 1 ${board} >& /dev/null ; then
            if [ "${state/missing-roaches/}" = "${state}" ] ; then
              kcpmsg -l warn "dropping resource ${board} as unreachable, unregistered, unused and inactive"
              unset resource_set[$board]
              # TODO: stop the matching sensor monitor
            fi 
          fi 
        fi
      fi
    fi
  done
}

function validate_instruments()
{
  # TODO: split into validate*size and validata*stream ? 

  if [ "${#instruments_deployed[@]}" -le 0 ] ; then
    kcpmsg -l fatal "no instruments deployed"
    return
  fi

  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    kcpmsg -l debug "checking templates for instrument ${instrument}"

    if [ -f ${template} ] ; then

      top=$(cat $template  | tr ',=' '\n' | grep ROACH[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

      if [ -z "${top}" ] ; then
        if [ "${state/missing-roaches/}" != "${state}" ] ; then
          kcpmsg -l warn "unable to determine roaches needed for ${instrument}, assuming it hardcodes them"
        else
          kcpmsg -l fatal "unable to determine resource requirements for instrument ${instrument}"
        fi 
      else 
        instruments_sizes[${instrument}]=$[top+1]

        kcpmsg "instrument ${instrument} requires ${instruments_sizes[${instrument}]} resources"
      fi

      top=$(cat $template  | tr ',=' '\n' | grep INPUT[0-9] | tr -dc '[0-9\n]' | sort -n | tail -1)

      if [ -z "${top}" ] ; then
        kcpmsg -l fatal "unable to determine input count for instrument ${instrument}"
      else 
        instruments_inputs[${instrument}]=$[top+1]

        kcpmsg "instrument ${instrument} requires ${instruments_inputs[${instrument}]} inputs"
      fi

      if which ike > /dev/null ; then 
        instruments_streams[${instrument}]=$(ike -o -k output_products $template | tr -s ' ,\n' ':' )
      else 
        instruments_streams[${instrument}]=$(grep '^ *output_products' $template | cut -f2 -d = | tr -s ' ,\n' ':' )
      fi

      if [ -z "${instruments_streams[${instrument}]}" ] ; then
        kcpmsg -l error "no data products discoverable in instrument ${instrument}"
      else 
        kcpmsg -l debug "streams for ${instrument} are ${instruments_streams[${instrument}]}"
      fi

    else
      kcpmsg -l fatal "no template available for instrument ${instrument}"
    fi

  done

}

#################################################################################
# misc

function get_katcp_reply()
{
  get=$1
  as=$2

  while read cmd code extra ; do 
    case "${cmd}" in 
      (\#${get})
        if [ -n "${as}" ] ; then
          echo "#${as} ${code} ${extra}"
        fi
        ;;
      (\!${get})
        if [ -n "${as}" ] ; then
          echo "!${as} ${code} ${extra}"
        fi
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          return 1
        fi
        ;;
      (\!*)
        kcpmsg -l warn "discarding unexpected response ${cmd}"
        ;;
      (\?*)
        kcpmsg -l fatal "rejecting untimely request ${cmd}, still busy servicing ${get}"
        echo "!${cmd:1} fail busy"
        ;;

    esac
  done

}

function get_katcp_inform()
{
  get=$1
  match=$2

  while read cmd code extra ; do 
    case "${cmd}" in 
      (\#${get})
        if [ -n "${match}" ] ; then 
          if [ "${match}" = "${code}" ] ; then
            result=${extra}
          fi
        else 
          result=${extra}
        fi
        ;;
      (\!${get})
        if [ "${code}" = "ok" ] ; then
          return 0
        else
          return 1
        fi
        ;;
      (\!*)
        kcpmsg -l warn "discarding unexpected response ${cmd}"
        ;;
      (\?*)
        kcpmsg -l fatal "rejecting untimely request ${cmd}, still busy servicing ${get}"
        echo "!${cmd:1} fail busy"
        ;;

    esac
  done

}

function make_subarray_sensors()
{
  echo "?var-declare ${1}*device-status* sensor,map"
  get_katcp_reply var-declare

  echo "?var-set ${1}*device-status* ok string :value"
  get_katcp_reply var-set
  echo "?var-set ${1}*device-status* ${1:-system}\_health string :help"
  get_katcp_reply var-set
  echo "?var-set ${1}*device-status* nominal string :status"
  get_katcp_reply var-set
  echo "?var-set ${1}*device-status* discrete string :type"
  get_katcp_reply var-set

  echo "?var-set ${1}*device-status* ok       string :range#0"
  get_katcp_reply var-set
  echo "?var-set ${1}*device-status* degraded string :range#1"
  get_katcp_reply var-set
  echo "?var-set ${1}*device-status* fail     string :range#2"
  get_katcp_reply var-set

  echo "?var-declare ${1}*instrument-state* sensor,map"
  get_katcp_reply var-declare

  echo "?var-set ${1}*instrument-state* ${1:-system}\_instrument\_state string :help"
  get_katcp_reply var-set
  echo "?var-set ${1}*instrument-state* string string :type"
  get_katcp_reply var-set
  echo "?var-set ${1}*instrument-state* unknown string :status"
  get_katcp_reply var-set
  echo "?var-set ${1}*instrument-state* none string :value"
  get_katcp_reply var-set

  echo "?broadcast ${1} interface-changed sensor-list"
  get_katcp_reply broadcast
}

# name, help, type, units, value, status

function make_plain_sensor()
{
  echo "?var-declare ${1} sensor,map"
  get_katcp_reply var-declare

  echo "?var-set ${1} ${2// /\\_} string :help"
  get_katcp_reply var-set
  echo "?var-set ${1} ${3} string :type"
  get_katcp_reply var-set
  echo "?var-set ${1} ${4} string :units"
  get_katcp_reply var-set

  echo "?var-set ${1} ${5} string :value"
  get_katcp_reply var-set
  echo "?var-set ${1} ${6} string :status"
  get_katcp_reply var-set

}

function make_instrument_sensors()
{
  file=${CORR_DIR}/${1}-${2}

  bandwidth=$(grep '^ *bandwidth *=' ${file}  | cut -f2 -d= )
  centerfrequency=$(grep '^ *true_cf *=' ${file}  | cut -f2 -d= )
  channels=$(grep '^ *n_chans *=' ${file}  | cut -f2 -d= )

  if [ -z "${bandwidth}" ] ; then
    kcpmsg -l error "unable to determine bandwidth for instrument ${1} in array ${2}"
  fi

  if [ -z "${centerfrequency}" ] ; then
    kcpmsg -l error "unable to determine centerfrequency for instrument ${1} in array ${2}"
  fi

  if [ -z "${channels}" ] ; then
    kcpmsg -l error "unable to determine channels for instrument ${1} in array ${2}"
  fi

  t=${instruments_streams[${2}]}

  for stream in ${t//:/ } ; do 

    make_plain_sensor "${1}*${stream}.bandwidth*"       "bandwidth of ${stream}"          integer Hz ${bandwidth} nominal
    make_plain_sensor "${1}*${stream}.centerfrequency*" "true sky frequency of ${stream}" integer Hz ${centerfrequency} nominal
    make_plain_sensor "${1}*${stream}.channels*"        "channels in ${stream}"           integer none ${channels} nominal

  done

  make_plain_sensor "${1}*synchronisation-epoch*"      "last synchronisation time"       integer seconds 0 unknown

  for fpg in $(grep '^ *bitstream' "$file") ; do 
    if [ -f "$fpg" ] ; then
      t=${fpg##*/}
      prefix=${t%%.*}

      echo "?var-declare ${1}*gateware.${prefix}.user* version,string"
      get_katcp_reply var-declare
      echo "?var-declare ${1}*gateware.${prefix}.library* version,string"
      get_katcp_reply var-declare

      for revision in $(grep 'meta.*77777.*commit_hash'  "$fpg"  | tr -s '\t' ' '  | tr -s ' ' | cut -f 4- -d ' ' | tr ' ' '=' ) ; do 
        if [ "$revision" = "${v/lib//}" ] ; then 
          echo "?var-set ${1}*gateware.${prefix}.user* ${revision##*=} string" 
        else
          echo "?var-set ${1}*gateware.${prefix}.library* ${revision##*=} string" 
        fi
        get_katcp_reply var-set
      done
    fi
  done

  echo "?broadcast ${1} interface-changed sensor-list"
  get_katcp_reply broadcast
}

function adjust_instrument_sensors()
{
  subarray=${1}
  status=${2}

  echo "?var-set ${subarray}*device-status* ${status} string :status"
  get_katcp_reply var-set

  echo "?var-set ${subarray}*instrument-state* ${status} string :status"
  get_katcp_reply var-set

  case "${status}" in 
    (nominal)
      value="ok"
    ;;
    (warn)
      value="degraded"
    ;;
    (*)
      value="fail"
    ;;
  esac

  echo "?var-set ${subarray}*device-status* ${value} string :value"
  get_katcp_reply var-set

  if [ "$#" -gt 2 ] ; then
    instrument=${3}
    echo "?var-set ${subarray}*instrument-state* ${instrument} string :value"
    get_katcp_reply var-set
  fi
}

function activate_servlet_sensors()
{
  declare -a vector

  i=0
  state=query
  remote=$1

  echo "?relay ${remote} relay ${remote} sensor-list"

  while read cmd code extra ; do 
    case "${cmd}" in 
      (\#relay) 
        if [ "${state}" != "query" ] ; then
          kcpmsg -l error "encountered late sensor list inform message"
          return 1
        fi
        vector[${#vector[@]}]=${code}
        ;;
      (\!relay) 

        if [ "${code}" != "ok" ] ; then
          kcpmsg -l error "unable to activate sensor retrieval"
          return 1
        fi

        if [ "${state}" = "query" ] ; then
          state=ask
          if [ -n "${extra}" ] ; then
            if [ "${extra}" != "${#vector[@]}" ] ; then
              kcpmsg -l error "problem - sensor logic claims ${extra} sensors but only returned ${#vector[@]}"
              return 1
            fi
          fi
        fi

        if [ "$i" -lt "${#vector[@]}" ] ; then
          kcpmsg -l debug "selecting auto strategy for sensor ${vector[$i]} number $i of ${#vector[@]}"
          echo "?relay ${remote} relay ${remote} sensor-sampling ${vector[$i]} auto"
# maybe look at the reply ? 
          i=$[i+1]
        else 
          kcpmsg "found and loaded $i sensors"
          return 0
        fi
        ;;
      (\?*)
        kcpmsg -l error "rejecting untimely request ${cmd}, still busy interrogating sensors"
        echo "!${cmd:1} busy"
        ;;
    esac
  done
}

#################################################################################
# primary requests 

function array_list()
{
  shift

  echo ?listener-list $*
  while read cmd label port host ; do 
    case "${cmd}" in 
      (\#listener-list)
        compound=${subarray_list[$label]}
        if [ -n "${compound}" ] ; then
          if [ "${host}" = "0.0.0.0" ] ; then
            unset host
          fi
          echo "#array-list ${label} ${host}${host:+:}${port} ${compound//-/ }"
        fi
        ;;
      (\!listener-list)
        if [ "${port}" = "not-found" ] ; then
          echo "!array-list ${label} unknown-array"
        else
          echo "!array-list ${label}"
        fi
        return 
        ;;
    esac
  done
}

function array_assign()
{
  shift

  if [ "$#" -lt 3 ] ; then
    kcpmsg "insufficient parameters"
    echo "!array-assign fail usage"
    return
  fi

  validate_subarray_list
  validate_instruments

  key=$1

  if [ -n "${subarray_list[$key]}" ] ; then
    kcpmsg "array ${key} already in use"
    echo "!array-assign fail already-exists"
    return
  fi

  for file in ${CORR_DIR}/${key}-* ; do
    if [ -f ${file} ] ; then
      if rm ${file} ; then
        kcpmsg -l debug "removing old config ${file}"
      else 
        kcpmsg -l error "unable to remove old config file ${file}"
        echo "!array-assign fail read-logs"
        return
      fi
    fi
  done

  shift

  match=0

  for instrument in ${instruments_deployed[*]} ; do
    if [ ${instruments_inputs[${instrument}]} = "$#" ] ; then
      match=$[match+1]
    fi
  done

  if [ "${match}" -le "0" ] ; then
    kcpmsg -l error "no instruments available for a subarray of $# inputs"
    echo "!array-assign fail unsupported-size"
    return
  fi

  kcpmsg -l info "have ${match} instruments on offer for a subarray of $# inputs"

  echo "?group-create $key"
  if ! get_katcp_reply group-create ; then
    echo "!array-assign fail read-logs"
    return
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    t="${key//[^0-9]/}"
    if [ "$t" -gt 0 ] ; then
      port=$[base_port+t]
      if [ "$port" -gt "${base_port}" ] ; then
        kcpmsg "selecting name derived port ${port}"
      else
        kcpmsg -l warn "malformed port ${port}, falling back to automatic selection"
        port=0
      fi
    else 
      kcpmsg "will select a free port for array other than rts"
      port=0
    fi
  fi

  echo "?listener-create ${key} ${port} 0.0.0.0"
  if ! get_katcp_reply listener-create ; then
    echo "?group-halt ${key}"
    get_katcp_reply group-halt
    echo "!array-assign fail network"
    return
  fi

# TODO - retrieve port number for return code
  if [ "$port" -le "0" ] ; then
    echo "?listener-list ${key}" 
    result=0
    if ! get_katcp_inform listener-list ${key} ; then
      echo "?group-halt ${key}"
      get_katcp_reply group-halt
      echo "!array-assign fail read-logs"
      return
    fi
    port=${result%% *}
    if [ "${port}" -le "0" ] ; then
      kcpmsg -l error "unable to determine port for ${key} - got ${result}"
      echo "?group-halt ${key}"
      get_katcp_reply group-halt
      echo "!array-assign fail read-logs"
      return
    fi
  fi 

#  echo "?client-exec subordinate ${key} cmc-subordinate ${key} $*"
#  if ! get_katcp_reply client-exec ; then
#    echo "?group-halt ${key}"
#    echo "!array-assign fail task-start"
#    return
#  fi

  unset t

  while [ -n "$1" ] ; do
    t=${t}${t:+-}${1}
    shift
  done

  subarray_list[$key]=$t

  make_subarray_sensors ${key}

  echo "!array-assign ok ${port}"
}

function array_halt()
{
  shift

  key=$1

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!array-halt fail usage"
    return
  fi

  validate_subarray_list

  if [ -z "${subarray_list[$key]}" ] ; then
    kcpmsg -l error "no state available for array ${key}"
    echo "!array-halt fail unknown-item"
    return
  fi

  kcpmsg "my state for $key is ${subarray_list[$key]}"

  unset subarray_list[$key]

  for board in ${!resource_use[*]} ; do
    if [ "${resource_use[${board}]}" = "$key" ] ; then
      unset resource_use[${board}]
    fi
  done

  echo "?group-halt ${key}"

  get_katcp_reply group-halt array-halt
}

function resource_list()
{
  shift

  validate_subarray_list
  validate_resource_set
  validate_resource_use

  if [ -n "$1" ] ; then

    if [ -z "${resource_set[$1]}" ] ; then
      kcpmsg -l error "resource $1 not found"
      echo "!resource-list fail unknown-item"
      return 1
    fi

    echo "#resource-list $1 ${resource_set[$1]} ${resource_use[$1]}"

  else

    for board in ${!resource_set[*]} ; do
      echo "#resource-list ${board} ${resource_set[${board}]} ${resource_use[${board}]}"
    done

  fi

  echo "!resource-list ok"
}

function resource_mark()
{
  shift

  if [ "$#" -lt 2 ] ; then
    kcpmsg -l error "insufficient arguments"
    echo "!resource-mark fail usage"
    return 1
  fi

  if [ -z "${resource_set[$1]}" ] ; then
    kcpmsg -l error "unknown resource ${1}"
    echo "!resource-mark fail unknown-item"
    return 1
  fi

  case "${2}" in
    (up) 
      if ping -W 2 -n -q -c 1 $1 >& /dev/null ; then
        resource_set[$1]="up"
      else
        if [ "${state/missing-roaches/}" != "${state}" ] ; then
          kcpmsg -l warn "resource $1 not responsive but taking it to be ok"
          resource_set[$1]="up"
        else
          kcpmsg -l error "resource $1 unresponsive"
          resource_set[$1]="standby"
          echo "!resource-mark fail read-logs"
          return 1
        fi
      fi
      ;;
    (standby) 
      if [ -n "${resource_use[$1]}" ] ; then
        kcpmsg -l error "refusing to release resource $1 held by array ${resource_use[$1]}"
        echo "!resource-mark fail in-use"
        return
      fi
      resource_set[$1]="standby"
      ;;
    (reset) 
      if [ -n "${resource_use[$1]}" ] ; then
        kcpmsg -l error "refusing to release resource $1 held by array ${resource_use[$1]}"
        echo "!resource-mark fail in-use"
        return
      fi
      kcpcmd -s "$1" restart 
      resource_set[$1]="standby"
      ;;
    (*) 
      kcpmsg -l error "unknown marking ${2} for resource ${1}"
      echo "!resource-mark fail usage"
      return 1
      ;;
  esac

  echo "!resource-mark ok"
}

#################################################################################
# subordinate requests

function instrument_list()
{
  shift

  for instrument in ${instruments_deployed[*]} ; do 
    t=${instruments_streams[${instrument}]}
    echo "#instrument-list ${instrument} ${t//:/ }"
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  shift

  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "insufficient arguments"
    echo "!instrument-probe fail usage"
    return
  fi

  validate_subarray_list
  validate_instruments
  validate_resource_set
  validate_resource_use
  validate_resource_free

  instrument=$1

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg -l error "no information about instrument ${instrument} found"
    echo "!instrument-probe fail unknown-item"
    return
  fi

  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg -l warn "would need ${need} boards but only have ${have}"
    echo "!instrument-probe ok oversubscribed"
    return
  fi

  kcpmsg "would allocate ${need} boards of ${have} available"

  echo "!instrument-probe ok sufficient"
}

function instrument_activate()
{
  shift

  status=nominal

  if [ "$#" -lt 2 ] ; then
    kcpmsg -l error "insufficient arguments (special case)"
    echo "!instrument-activate fail usage"
    return
  fi

  validate_subarray_list
  validate_instruments
  validate_resource_set
  validate_resource_use
  validate_resource_free

  subarray=$1
  instrument=$2

  need=${instruments_sizes[${instrument}]}

  if [ -z "${need}" ]  ; then
    kcpmsg -l error "no information about instrument ${instrument} found"
    echo "!instrument-activate fail unknown-item"
    return
  fi

  if [ -z "${subarray_list[${subarray}]}" ] ; then
    kcpmsg -l error "subarray ${subarray} does not seem to exist"
    echo "!instrument-activate fail unknown-item"
    return
  fi

  have=${#resource_free[*]}

  if [ "${have}" -lt "${need}" ] ; then
    kcpmsg -l warn "would need ${need} boards but only have ${have}"
    #echo "!instrument-activate ok oversubscribed"
    echo "!instrument-activate fail oversubscribed"
    return 1
  fi

  i=0

  unset resource_grab
  declare -a resource_grab

  while [ "$i" -lt "${need}" ] ; do
    resource_grab[$i]=${resource_free[$i]}
    i=$[i+1]
  done

  compound=${subarray_list[$subarray]}

  kcpmsg "about to configure instrument ${instrument} for ${subarray} with ${resource_grab[*]} resources and inputs ${compound//-/ }"
  
  nextport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

  kcpmsg "selecting port ${nextport} for instrument ${instrument} of array ${subarray}"

  if ! cmc-config ${subarray} ${instrument} ${nextport} ${compound//-/ } ${resource_grab[*]} ; then
    kcpmsg -l error "unable to generate config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

#echo "?client-exec ${subarray}-${instrument} ${subarray} network-cmc-corr-stub" ${CORR_DIR}/${subarray}-${instrument} ${nextport}
  echo "?client-exec ${subarray}-${instrument} ${subarray} kcprun corr2_servlet.py -p ${nextport}"
  if ! get_katcp_reply client-exec ; then
    echo "!instrument-activate fail task-start"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-config client ${subarray}-${instrument}"
  if ! get_katcp_reply client-config ; then
    status=warn
  fi

  sleep 2

  echo "?client-connect localhost:${nextport} ${subarray}"
  if ! get_katcp_reply client-connect ; then
    echo "!instrument-activate fail network"
    echo "?client-halt ${subarray}-${instrument}"
    get_katcp_reply client-halt 
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-config client localhost:${nextport}"
  if ! get_katcp_reply client-config ; then
    status=warn
  fi

  if ! kcpcmd -k -t 300 -r -s localhost:${nextport} create ${CORR_DIR}/${subarray}-${instrument} ; then 
    kcpmsg -l error "unable to load config for instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  echo "?client-rename corr localhost:${nextport}" 
  if ! get_katcp_reply client-rename ; then
    # TODO: kill the corr instance to release resources
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  if [ -n "${dmc_address}" ] ; then
    echo "?client-exec dmc-${subarray}-${instrument} ${subarray} kcpmpx -r -l dmc "${dmc_address}" -k -l cmc - -m -e cmc-dmc"
    if ! get_katcp_reply client-exec ; then
      kcpmsg -l warn "unable to launch dmc synchronisation helper"
      status=warn
    else
      kcpmsg "launching synchronisation dmc monitor"
      sleep 2
    fi
  else
    kcpmsg -l warn "no dmc defined thus synchronisation"
  fi

  kcpmsg -l warn "waiting for initialisation ... patience"

  if ! kcpcmd -k -t 300 -r -s localhost:${nextport} initialise ; then 
    kcpmsg -l error "unable to initialise instrument ${instrument} in subarray ${subarray}"
    echo "!instrument-activate fail read-logs"
    adjust_instrument_sensors ${subarray} error
    return 1
  fi

  for board in ${resource_grab[*]} ; do
    kcpmsg "assigning resource ${board} to ${subarray}"
    resource_use[${board}]=${subarray}
  done

  make_instrument_sensors ${subarray} ${instrument}

  if [ "${state/no-sensors/}" = "${state}" ] ; then
    extraport=$(seq ${corr_base} ${corr_end} | grep -E -v -w $(netstat -tan | tr -s ' ' | grep '^tcp '  | cut -f4 -d ' '  | cut -f2 -d: | sort -nu | tr '\n' '|')0 | head -1)

    kcpmsg "selecting ${extraport} for sensor"

    echo "?client-exec monitor-${subarray}-${instrument} ${subarray} kcprun -n CORR2INI=${CORR_DIR}/${subarray}-${instrument} corr2_sensor_servlet.py -p ${extraport}"

    if ! get_katcp_reply client-exec ; then
      kcpmsg -l warn "unable to launch sensors for instrument ${instrument} in ${subarray} but going on anyway"
      status=warn
    fi

    echo "?client-config client monitor-${subarray}-${instrument}"
    if ! get_katcp_reply client-config ; then
      status=warn
    fi

    sleep 2

    echo "?client-connect localhost:${extraport} ${subarray}"
    if ! get_katcp_reply client-connect ; then
      status=warn
    fi

    echo "?client-config client localhost:${extraport}"
    if ! get_katcp_reply client-config ; then
      status=warn
    fi

    echo "?client-rename corr-sensors localhost:${extraport}" 
    if ! get_katcp_reply client-rename ; then
      status=warn
    fi

    echo "?client-config fixed corr-sensors"
    if ! get_katcp_reply client-config ; then
      kcpmsg -l warn "unable to configure sensor monitor"
      status=warn
    fi

    kcpmsg "about to interrogate servlet sensors"

    activate_servlet_sensors corr-sensors

  else
    kcpmsg -l warn "sensor servlet inhibited by configuration"
  fi

  echo "!instrument-activate ok"

  adjust_instrument_sensors ${subarray} ${status} ${instrument}
}

#################################################################################
# mainloop

validate_instruments
validate_resource_set

echo "?log-limit fatal"
get_katcp_reply log-limit

while read line ; do 

  i=0;
  rest=${line}
  while [ -n "${rest}" ] ; do
    command_vector[$i]=${rest%% *}
    update=${rest#* }
    if [ "${update}" = "${rest}" ] ; then
      rest=""
    else 
      rest=${update}
    fi
    i=$[i+1]
  done

  max=$i
  cmd=${command_vector[0]}

  case "${cmd}" in
    (\?array-list) 
      array_list ${command_vector[@]}
      ;;
    (\?array-assign) 
      array_assign ${command_vector[@]}
      ;;
    (\?array-halt) 
      array_halt ${command_vector[@]}
      ;;
    (\?resource-list) 
      resource_list ${command_vector[@]}
      ;;
    (\?resource-mark) 
      resource_mark ${command_vector[@]}
      ;;
    (\?instrument-list) 
      instrument_list ${command_vector[@]}
      ;;
    (\?instrument-probe) 
      instrument_probe ${command_vector[@]}
      ;;
    (\?instrument-activate) 
      instrument_activate ${command_vector[@]}
      ;;
    (*)
      if [ "${cmd:0:1}" = '?' ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd:1} fail unknown-item"
      fi
      ;;
  esac

  i=0
  while [ ${i} -lt ${max} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done
  
done
