#!/bin/bash

# valid command names and their minimum parameter count

declare -A -r command_set=([resource-reload]=1 [resource-list]=1 [resource-mark]=3 [subordinate-create]=3 [subordinate-list]=1 [subordinate-halt]=2 [instrument-list]=1 [instrument-probe]=2 [cmc-halt]=1)
declare -A -r command_help=([resource-reload]="refresh resource status (?resource-reload)" [resource-mark]="set availability of a processing resource (?resource-mark resource marking)" [resource-list]="show processing resources (?resource-list [resource])" [subordinate-halt]="halt a subarray (?subordinate-halt [subarray])" [subordinate-list]="show subarrays (?subordinate-list)" [subordinate-create]="define and launch a subarray (?subordinate-create subarray [inputs]*)" [instrument-list]="show available instruments (?instrument-list)" [instrument-probe]="test if a group of instruments can currently be run (?instrument-probe [instruments]*)" [cmc-halt]="power down the cmc server (?cmc-halt)")

declare -A -r inform_set=([group-destroyed]=1)

#################################################

### hidden api functions ### resources ##################

function group_destroyed()
{
  local subarray resource board prefix now count list
  local -a roaches skarabs

  shift

  subarray=$1

  if [ -z "${subarray}" ] ; then
    kcpmsg -l warn "unable to identify subarray to be released"
    return 1
  fi

  kcpmsg "invoking group destruction callback for ${subarray}"

  push_failure

  fetch_var "resources"

  if ! pop_failure ; then
    kcpmsg -l warn "unable to query resource set while deallocating subarray ${subarray}"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        prefix=${resource%:*}
        if [ "${var_result[${prefix}:type]}" = roach ] ; then
          board=${prefix#resources:}
          roaches+=("${board}")
        elif [ "${var_result[${prefix}:type]}" = skarab ] ; then
          board=${prefix#resources:}
          skarabs+=("${board}")
        fi
      fi
    fi
  done

# if already programmed, things may take longer, thus run it in parallel
  list="${roaches[*]}"
  if [ -n "${list}" ] ; then
    kcppar -q -i -n -s "${list// /,}" -x progdev
  fi

# TODO: could we have a bulk skarab deprogram option ?

  count=0

  push_failure

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        prefix=${resource%:*}
        now=""
        if [ "${var_result[${prefix}:type]}" = roach ] ; then
          board=${prefix#resources:}

          if kcpcmd -f -kr -s ${board}:7147 progdev ; then
            now=$(date +%s)
          else
            kcpmsg -l error "unable to deprogram roach ${board} which was part of array ${subarray}"
            set_failure
          fi

        elif [ "${var_result[${prefix}:type]}" = skarab ] ; then
          board=${prefix#resources:}
# WARNING: reboot of skarab takes too long, clear timeout so that the next resource check sees if given skarab is reachable
          kcprun -q -t 250 -j reboot_skarab.py ${board} 10
        fi

        if [ -n "${now}" ] ; then
          send_request   var-delete  "${prefix}:when"
          retrieve_reply var-delete
          send_request   var-set     resources ${now} string ":${board}:when"
          retrieve_reply var-set
        else
# redundant test; it must have been ready which now implies a mode auto
          if [ "${var_result[${prefix}:mode]}" = "auto" ] ; then
            send_request   var-delete  "${prefix}:mode"
            retrieve_reply var-delete

            send_request   var-set   resources standby string ":${board}:status"
            retrieve_reply var-set
          fi

        fi

        send_request   var-delete  "${resource}"
        retrieve_reply var-delete

        count=$[count+1]

      fi
    fi
  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to free all resources held by ${subarray}"
  else
    kcpmsg -l info "released ${count} resources held by ${subarray}"
  fi
}

### api functions ### resources #########################

function resource_reload()
{
  if check_resources ; then
    echo "!resource-reload ok"
  else
    echo "!resource-reload fail"
  fi
}

function resource_list()
{
  local key board prefix setting

  shift

  check_resources

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "resources:${1,,}"
  else
    fetch_var "resources"
  fi

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve resource variables"
    echo "!resource-list fail"
  fi

  for key in "${!var_result[@]}" ; do

    if [ "${key##*:}" = status ] ; then
      prefix="${key%:status}"
      board="${prefix#resources:}"

      if [ -n "${board}" ] ; then

        if [ "${var_result[${prefix}:mode]}" != "auto" ] ; then
          kcpmsg "resource ${board} is in mode ${var_result[${prefix}:mode]}"
        fi

        if [ -n "${var_result[${prefix}:holder]}" ] ; then
          echo "#resource-list ${board} ${var_result[${prefix}:status]} ${var_result[${prefix}:holder]}"
        else
          echo "#resource-list ${board} ${var_result[${prefix}:status]}"
        fi
      else
        kcpmsg -l error "problems processing resource status ${key}"
      fi
    fi
  done

  echo "!resource-list ok"
}

function resource_mark()
{
  local board status

  shift

  board=${1,,}
  status=$2

  check_resources

  push_failure

  fetch_var "resources:${board}"

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve resource ${board}"
    echo "!resource-mark fail unknown-item"
    return 1
  fi

  case "${status}" in
    (up)
      if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
        if ! kcpcmd -k -r -i -s "${board}" watchdog >& /dev/null ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l error "resource ${board} unresponsive"
            echo "!resource-mark fail network"
            return 1
          fi
          kcpmsg -l warn "roach resource ${board} not responsive but taking it to be ok"
        fi
      fi

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "up" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" up     string ":${board}:status"
        retrieve_reply var-set
      fi

# WARNING: introduces asymmetry: marking it up puts it into auto mode again
      if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" auto   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (standby)

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" standby  string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
#     (reset)
#
#       if [ "${var_result[resources:${board}:type]}" != roach ] ; then
#         kcpmsg -l warn "no way of resetting resource ${board}"
#         echo "!resource-mark fail read-logs"
#         return 1
#       fi
#
#       if [ -n "${var_result[resources:${board}:holder]}" ] ; then
#         kcpmsg -l warn "unwilling to reset resource ${board} as it is used by ${var_result[resources:${board}:holder]}"
#         echo "!resource-mark fail in-use"
#         return 1
#       fi
#
#       push_failure
#
#       if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
#         send_request   var-delete  "resources:${board}:status"
#         retrieve_reply var-delete
#
#         send_request   var-set  "resources" standby  string ":${board}:status"
#         retrieve_reply var-set
#       fi
#
#       if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
#         send_request   var-delete  "resources:${board}:mode"
#         retrieve_reply var-delete
#
#         send_request   var-set  "resources" auto   string ":${board}:mode"
#         retrieve_reply var-set
#       fi
#
#       if ! pop_failure ; then
#         kcpmsg -l error "unable to update resource state for ${board}"
#         echo "!resource-mark fail read-logs"
#         return 1
#       fi
#
#       if ! kcpcmd -k -i -r -s "$1" restart ; then
#         kcpmsg -l error "unable to restart resource ${board}"
#         echo "!resource-mark fail network"
#         return 1
#       fi
#
#       echo "!resource-mark ok"
#       return 0
#     ;;
    (*)
      kcpmsg -l error "unknown marking ${status} for resource ${board}"
      echo "!resource-mark fail usage"
      return 1
    ;;
  esac
}

### api functions ### subordinates ######################

function subordinate_list()
{
  local -A ports hosts groups
  local -a v
  local group port host key
  local c t

  shift

  push_failure

  send_request    listener-list "$*"
  retrieve_inform listener-list

  if ! pop_failure ; then
    echo "!subordinate-list fail"
    return 1
  fi

# WARNING: we assume one listener per group here

  kcpmsg -l debug "my keys are ${!inform_result[@]}"
  for key in "${!inform_result[@]}" ; do
    v=(${inform_result[${key}]})
    if [ -z "${v[2]}" ] ; then
      group="${key}"
    else
      group=${v[2]}
    fi

    ports[${key}]=${v[0]}
    hosts[${key}]=${v[1]}
    groups[${key}]=${group}

  done

  push_failure

  c=0
  for key in "${!groups[@]}" ; do

    group="${groups[${key}]}"

    fetch_var  "${group}*subordinate*"

    if clear_failure ; then

      subarray="${var_result[${group}*subordinate*]}"

      if [ -n "${subarray}" ] ; then

        if [ "${key}" != "${subarray}" ] ; then
          kcpmsg -l warn "possible consistency issue where listener label ${key} does not match subarray name ${subarray}"
        fi

        port=${ports[${group}]}
        host=${hosts[${group}]}

        kcpmsg -l debug "considering ${group} with listener ${host}:${port}"


        if [ "${host}" = "0.0.0.0" ] ; then
          unset host
        fi

        fetch_var "${group}*inputs*"
        flatten_var

        if clear_failure ; then
          echo "#subordinate-list "${subarray}" ${host}${host:+:}${port} ${var_flat}"
          c=$[c+1]
        fi

      fi

    fi
  done

  pop_failure

  if [ "${c}" -lt "$#"  ] ; then
    kcpmsg -l debug "was given $# parameters, could only list ${c} subarrays"
    echo "!subordinate-list fail unknown-array"
    return 1
  fi

  echo "!subordinate-list ok"
  return 0
}

function subordinate_create()
{
  local port key prefix group file
  local i t

  shift

# at the moment there is only one instrument per group
  key=$1
  group=${key}

  if [ "${group}" = primary ] ; then
    kcpmsg -l warn "name ${group} reserved for internal use"
    echo "!subordinate-create fail already-exists"
    return 1
  fi

  push_failure

  send_request   group-list "${group}"
  retrieve_reply group-list

  if pop_failure ; then
    kcpmsg -l warn "array ${group} already in use"
    echo "!subordinate-create fail already-exists"
    return 1
  fi

  if [ -n "${CORR_DIR}" ] ; then
    for file in ${CORR_DIR}/${key}-* ; do
      if [ -f ${file} ] ; then
        if rm ${file} ; then
          kcpmsg -l debug "removing old config ${file}"
        else
          kcpmsg -l error "unable to remove old config file ${file}"
          echo "!subordinate-create fail read-logs"
          return
        fi
      fi
    done
  fi

  push_failure

  send_request   group-create "${group}"
  retrieve_reply group-create

  if ! pop_failure ; then
    kcpmsg -l warn "unable to create group ${group} for array"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  push_failure

# used to label a subarray group, so that halt can't be used to kill primary
  send_request   var-declare "${group}*subordinate*" string
  retrieve_reply var-declare

  send_request   var-set "${group}*subordinate*" "$key" string
  retrieve_reply var-set

  send_request   var-declare "${group}*inputs*" array
  retrieve_reply var-declare

  shift
  i=0

  while [ "$#" -ge 1 ] ; do
    send_request   var-set "${group}*inputs*" "$1" string "#$i"
    retrieve_reply var-set

    shift
    i=$[i+1]
  done

  if ! clear_failure ; then

    send_request   group-halt "${group}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to record inputs for group ${group}"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port:-7404}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    t="${key//[^0-9]/}"
    if [ "$t" -gt 0 ] ; then
      port=$[base_port+t]
      if [ "$port" -gt "${base_port}" ] ; then
        kcpmsg "selecting name derived port ${port}"
      else
        kcpmsg -l warn "malformed port ${port} thus falling back to automatic selection"
        port=0
      fi
    else
      kcpmsg "will select a free port for array other than rts"
      port=0
    fi
  fi

  push_failure

  send_request   listener-create "${key}" "${port}" "0.0.0.0" "${group}"
  retrieve_reply listener-create

  if [ "${port}" -le "0" ] ; then
    send_request listener-list "${key}"
    retrieve_inform listener-list "${key}"
    port=${inform_result[${key}]%% *}
    if [ "${port}" -le "0" ] ; then
      kcpmsg -l error "unable to determine port for ${key} - got ${result}"
      set_failure
    fi
  fi

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start listener for group ${group}"
    echo "!subordinate-create fail network"
    return 1
  fi

  send_request   client-exec subordinate ${key} cmc-subordinate ${key}
  retrieve_reply client-exec

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start control task for group ${group}"
    echo "!subordinate-create fail task-start"
    return 1
  fi

  pop_failure

# there is a chance this isn't needed with a proper mainloop
  sleep 0.1

  echo "!subordinate-create ok ${port}"
  return 0
}

function subordinate_halt()
{
  local group key

  shift

  key="$1"

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!subordinate-halt fail usage"
    return 1
  fi

  group="${key}"

  push_failure

  fetch_var "${group}*subordinate*"

  if ! pop_failure ; then
    kcpmsg -l error "could not locate variable suborinate in group ${group}"

    kcpmsg -l error "subarray ${key} not found and so not halted"

    echo "!subordinate-halt fail unknown-item"
    return 1
  fi

  push_failure

  send_request    group-halt "$key"
  retrieve_reply  group-halt

  if ! pop_failure ; then
    echo "!subordinate-halt fail read-logs"
    return 1
  fi

  echo "!subordinate-halt ok"
  return 0
}

### api functions ### instrument ########################

function instrument_list()
{
  local -A size input outputs
  local -a index
  local instrument key art availability

  shift

  check_resources

  if ! setup_instruments ; then
    echo "!instrument-list fail"
    return 1
  fi

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "instrument-size:$1"
  else
    fetch_var "instrument-size"
  fi

  if ! pop_failure ; then
    kcpmsg -l error "unable to retrieve instrument list"
    echo "!instrument-list fail"
  fi

  for key in "${!var_result[@]}" ; do
    instrument="${key#instrument-size:}"
    index+=("${instrument}")
  done

  for instrument in "${index[@]}" ; do
    push_failure

    fetch_var "instrument-size:${instrument}"
    size="${var_result[*]}"

    fetch_var "instrument-input:${instrument}"
    input="${var_result[*]}"

    fetch_var "instrument-outputs:${instrument}"
    outputs="${var_result[*]}"

    fetch_var "instrument-resources:${instrument}"
    availability="sufficient"

    for art in ${resource_types[*]} ; do
      if [ "${var_result[instrument-resources:${instrument}:${art}]}" -gt "${resource_free[${art}]}" ] ; then
        kcpmsg "instrument ${instrument} requires ${var_result[instrument-resources:${instrument}:${art}]} ${art} resources but currently only ${resource_free[${art}]} are available"
        availability="oversubscribed"
      fi
    done

    if ! pop_failure ; then
      kcpmsg -l error "unable to retrieve needed information for instrument ${instrument}"
    else
      echo "#instrument-list ${instrument} ${availability} ${size} ${input} ${outputs}"
    fi
  done

  echo "!instrument-list ok"
}

function instrument_probe()
{
  shift

  compute_resources "$@"

  if [ "$?" -eq 0 ] ; then
    echo "!instrument-probe ok sufficient"
    return
  fi

  if [ "$?" -eq 2 ] ; then
    echo "!instrument-probe ok oversubscribed"
    return
  fi

  echo "!instrument-probe fail"
}

### halt ###

function cmc_halt()
{
  shift

  if kcprun -j sudo shutdown -h now ; then
    echo "!cmc-halt ok"
  else
    echo "!cmc-halt fail"
  fi
}

#################################################

source cmc-lib.sh
source cmc-resource.sh
source cmc-instrument.sh

inhibit_logging
enable_misc_informs
register_commands primary

#################################################

init_resources
init_instruments

load_instruments
check_resources

#################################################

main_loop
