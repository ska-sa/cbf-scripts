#!/bin/bash

export KATCP_LABEL=cmc-resource

configuration=${CMC_CONFIG:-/etc/cmc.conf}

if [ -f "${configuration}" ] ; then
  source "${configuration}"

  if [ "${state/verbose-log/}" != "${state}" ] ; then
    set -x
  fi

  leases=${LEASE_FILE:-/var/lib/misc/dnsmasq.leases}

  if [ ! -f "${leases}" ] ; then
    kcpmsg -l fatal "no lease file to be found"
  fi

else
  kcpmsg -l fatal "unable to locate ${configuration} thus making things up"
  set -x

  if [ -f /var/lib/misc/dnsmasq.leases ] ; then
    leases=/var/lib/misc/dnsmasq.leases
  else
    leases=../tests/dnsmasq.leases
  fi
fi

### essential declarations ##############################

declare -a -r resource_types=(roach skarab)

# valid command names and their minimum parameter count
declare -A -r command_set=([resource-reload]=1 [resource-list]=1 [resource-mark]=3 [subordinate-create]=3 [subordinate-list]=1 [subordinate-halt]=2 [instrument-list]=1)

declare -A -r inform_set=([group-destroyed]=1)

declare -a command_vector
declare -i command_size=0

### queue library #######################################

declare -a queue_data
declare -i queue_tail=0

function clear_queue()
{
  local i=0

  while [ "${i}" -lt "${queue_tail}" ] ; do
    unset queue_data[${i}]
    i=$[i+1]
  done

  queue_tail=0
}

function add_queue()
{
  if [ "$#" -lt 1 ] ; then
    kcpmsg -l error "no parameters"
    return 1
  fi

  queue_data[${queue_tail}]="$*"

#  kcpmsg -l debug "queue[${queue_tail}]: $*"

  queue_tail=$[queue_tail+1]
}

function show_queue()
{
  local i

  kcpmsg -l debug "#### dump start ####"

  i=0
  while [ "${i}" -lt "${queue_tail}" ] ; do
    kcpmsg -l debug "queue[${i}]: ${queue_data[${i}]}"
    i=$[i+1]
  done

  kcpmsg -l debug "#### dump end ####"
}

### error stack #########################################

declare -a failure_stack
declare -i failure_depth=0

function push_failure()
{
  failure_depth=$[failure_depth+1]
  failure_stack[${failure_depth}]=0
}

# pop failure to be used in if statement where we return or we are no longer interested in error codes
# clear failure to be used in if statements where there is no return

function pop_failure()
{
  result=${failure_stack[${failure_depth}]}

#  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  if [ "${failure_depth}" -gt "0" ] ; then
    failure_depth=$[failure_depth-1]
  else
    kcpmsg -l warn "unwound stack too far"
  fi

  return ${result}
}

function clear_failure()
{
  result=${failure_stack[${failure_depth}]}

#  kcpmsg -l trace "stack at ${failure_depth} has code ${result}"

  failure_stack[${failure_depth}]=0

  return ${result}
}

function set_failure()
{
  failure_stack[${failure_depth}]=$[failure_stack[${failure_depth}]+1]
}

### transform line into vector ##########################

function make_vector()
{
  local i

  i=0
  while [ ${i} -lt ${command_size} ] ; do
    unset command_vector[$i]
    i=$[i+1]
  done

  command_size=0
  while [ $# -gt 0 ] ; do
    command_vector[${command_size}]=$1
    command_size=$[command_size+1]
    shift
  done

  kcpmsg -l debug "parsed ${command_size} parameters"
}

### io functions with failure stack #####################

send_count=0

function send_request()
{
  local name="$1"

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  if [ "${send_count}" -gt 0 ] ; then
    kcpmsg -l warn "sending ${send_count} request(s) without waiting for reply"
  fi

  send_count=$[send_count+1]

  echo "?$*"
}

function retrieve_reply()
{
  local name="$1"
  local line art reply code
  local -a vector

  if [ -z "$name" ] ; then
    set_failure
    return 1
  fi

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      reply=${vector[0]}

      if [ "${art}" = '#' ] ; then
        if [ -n "${inform_set[${reply:1}]}" ] ; then
          add_queue ${line}
        fi
      elif [ "${art}" = "!" ] ; then
        if [ "${reply:1}" = "${name}" ]; then
          send_count=$[send_count-1]
          code=${vector[1]}
          if [ "${code}" = "ok" ] ; then
            return 0
          else
            set_failure
            return 1
          fi
        else
          kcpmsg -l warn "discarding unexpected response ${reply:1}"
        fi
      fi
    fi
  done
}

declare -A inform_result

function retrieve_inform()
{
  local name="$1"
  local match="$2"
  local del line art reply label 
  local -a vector

  for del in "${!inform_result[@]}" ; do
    unset inform_result[${del}]
  done

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      reply="${vector[0]}"

      if [ "${art}" = '#' ] ; then
        if [ "${reply:1}" = "${name}" ] ; then
          label=${vector[1]}
          if [ -z "${match}" -o "${match}" = "${label}" ] ; then
            inform_result[${label}]="${line#* * }"
          fi
        elif [ -n "${inform_set[${reply:1}]}" ] ; then
          add_queue ${line}
        fi
      elif [ "${art}" = "!" ] ; then
        if [ "${reply:1}" = "${name}" ]; then
          send_count=$[send_count-1]
          code=${vector[1]}
          if [ "${code}" = "ok" ] ; then
            return 0
          else
            set_failure
            return 1
          fi
        else
          kcpmsg -l warn "discarding unexpected response ${reply:1}"
        fi
      fi
    fi
  done
}

declare -A var_result

function fetch_var()
{
  local match
  local del line art reply label
  local -a vector

  for del in "${!var_result[@]}" ; do
    unset var_result[${del}]
  done

  if [ "$1" = '-a' ] ; then
    shift
    echo "?var-show"
  else
    echo "?var-show $1"
  fi

  match=$1

  while read line ; do
    art=${line:0:1}
    if [ "${art}" = "?" ] ; then
      add_queue ${line}
    else
      vector=(${line})
      reply="${vector[0]}"

      if [ "${art}" = '#' ] ; then
        if [ "${reply}" = "#var-show" ] ; then
          label=${vector[1]}
          if [ -z "${match}" -o "${label}" != "${label#${match}}" ] ; then
            var_result[${label}]="${vector[2]}"
          fi
        elif [ -n "${inform_set[${reply:1}]}" ] ; then
          add_queue ${line}
        fi
      elif [ "${art}" = "!" ] ; then
        if [ "${reply}" = "!var-show" ]; then
          if [ "${vector[1]}" = "ok" ] ; then
            return 0
          else
            set_failure
            return 1
          fi
        else
          kcpmsg -l warn "discarding unexpected response ${reply:1}"
        fi
      fi
    fi
  done
}

### support functions ###################################

# instrument-size:name           - how many inputs does it need
# instrument-input:name          - what input product does it require
# instrument-outputs:name:#N     - what output products does it generate
# instrument-resources:name:type - how many boards of what type do we need

push_failure

send_request   var-declare  "instrument-size*"       map
retrieve_reply var-declare
send_request   var-declare  "instrument-input*"      map
retrieve_reply var-declare
send_request   var-declare  "instrument-outputs*"    map
retrieve_reply var-declare
send_request   var-declare  "instrument-resources*"  map
retrieve_reply var-declare

if ! pop_failure  ; then
  kcpmsg -l fatal "unable to declare essential instrument tracking state"
fi

function setup_instruments()
{
  local size instrument template geometry art count top available product i required input

  if [ "${#instruments_deployed[@]}" -le 0 ] ; then
    kcpmsg -l fatal "no instruments deployed"
    return 1
  fi

  push_failure

  available=0
  for instrument in ${instruments_deployed[*]} ; do
    template=${CORR_TEMPLATE}/${instrument}

    kcpmsg -l debug "checking templates for instrument ${instrument}"

    if [ -f ${template} ] ; then

      size=$(ike -o -k source_mcast_ips ${template} | tr -s ',' '\n' | wc -l)
      input=$(ike -o -k source_products ${template})

      if [ "${size}" -gt 0 -a -n "${input}" ] ; then

        kcpmsg "instrument ${instrument} uses ${size} inputs"

        send_request   var-declare instrument-outputs   array  ":${instrument}"
        retrieve_reply var-declare

        send_request   var-declare instrument-resources map    ":${instrument}"
        retrieve_reply var-declare

        send_request   var-set     instrument-size   "${size}"  string  ":${instrument}"
        retrieve_reply var-set

        send_request   var-set     instrument-input  "${input}" string  ":${instrument}"
        retrieve_reply var-set

        i=0
        for product in $(ike -o -k output_products ${template}) ; do
          send_request   var-set instrument-outputs "${product}" string ":${instrument}#${i}"
          retrieve_reply var-set
          i=$[i+1]
        done

        if [ "${i}" -le 0 ] ; then
          kcpmsg -l error "no data products discoverable in instrument ${instrument}"
          set_failure
        fi

        required=0
        for art in ${resource_types[*]} ; do

# could make it search for upper case only ... 
          required=$(ike -o -k hosts ${template} | tr -s , '\n' | sort -u | grep -ic ${art})

          kcpmsg "instrument ${instrument} requires ${required} ${art} resources"

          send_request   var-set instrument-resources "${required}" string ":${instrument}:${art}"
          retrieve_reply var-set
        done

        if [ "${required}" -le 0 ] ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l fatal "unable to determine resource needs for instrument ${instrument}"
            set_failure
          fi
        fi
      else
        kcpmsg -l error "unable to establish what and how many inputs ${instrument} requires"
        set_failure
      fi

    else
      kcpmsg -l fatal "no template available for instrument ${instrument}"
    fi

  done

  if ! pop_failure ; then
    kcpmsg -l error "unable to determine instrument layouts"
    return 1
  fi

  return 0
}

### support functions ###################################

# resources:name:when       - last time we checked it
# resources:name:status     - what the user status is
#
# resources:name:type       - what type of resource it is
# resources:name:mode       - did the user decide its status
# resources:name:holder     - which subarray owns it

push_failure
send_request   var-declare  "resources*"  map,readonly
retrieve_reply var-declare

if ! pop_failure  ; then
  kcpmsg -l fatal "unable to declare essential resource tracking state"
fi

function check_resources()
{
  local -l board
  local now mode art status when fresh key tmp board

  now=$(date +%s)

  for board in $(grep roach ${leases} | cut -f4 -d ' ') ; do

    push_failure

    fetch_var "resources:${board}"
    fresh=0

    if ! clear_failure ; then
      send_request   var-declare resources map    ":${board}"
      retrieve_reply var-declare

      send_request   var-set     resources roach  string ":${board}:type"
      retrieve_reply var-set

      send_request   var-set     resources auto   string ":${board}:mode"
      retrieve_reply var-set

      mode=auto
      art=roach
      when=${now}
      status=unknown

    else
      fresh=1

      mode="${var_result[resources:${board}:mode]}"
      art="${var_result[resources:${board}:type]}"
      when="${var_result[resources:${board}:when]}"
      status="${var_result[resources:${board}:status]}"

      if [ "${mode}" == auto ] ; then
        if [ "$[when+checkperiod]" -gt "${now}" ] ; then
          fresh=0
          send_request   var-delete  "resources:${board}:when"
          retrieve_reply var-delete
          send_request   var-delete  "resources:${board}:status"
          retrieve_reply var-delete
        fi
      fi
    fi

    if [ "${fresh}" = "0" ] ; then
      if kcpcmd -kir -f -t 2 -s "${board}" watchdog ; then
        status=up
      else
        status=standby
      fi

      send_request   var-set      "resources" ${now}     string ":${board}:when"
      retrieve_reply var-set
      send_request   var-set      "resources" ${status}  string ":${board}:status"
      retrieve_reply var-set

      kcpmsg "checked ${board} at ${when} showing status ${status}"
    fi

    if ! pop_failure  ; then
      kcpmsg -l fatal "unable to update status of board ${board}"
      return 1
    fi

  done

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to retrieve resource variables"
    return 1
  fi

  push_failure

  for key in "${!var_result[@]}" ; do
    if [ "${key##*:}" = "when" ] ; then
      when="${var_result[${key}]}"
      if [ "$[when+checkperiod]" -le "${now}" ] ; then
        tmp="${key#resources:}"
        board="${tmp%%:*}"
        if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
          if [ "${var_result[resources:${board}:status]}" = "up" ] ; then
            if [ "${var_result[resources:${board}:mode]}" = "auto" ] ; then
              if ! kcpcmd -kir -f -t 1 -s "${board}" watchdog >& /dev/null ; then
                send_request   var-set      "resources" standby string ":${board}:status"
                retrieve_reply var-set
              fi
            fi
          fi
        fi
      fi
    fi
  done

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to update expired resource"
    return 1
  fi

  return 0
}

### hidden api functions ### resources ##################

function group_destroyed()
{
  local subarray resource board t now count list
  local -a pool

  shift

  subarray=$1

  if [ -z "${subarray}" ] ; then
    kcpmsg -l warn "unable to identify subarray to be released"
    return 1
  fi

  kcpmsg "invoking group destruction callback for ${subarray}"

  push_failure

  fetch_var "resources"

  if ! pop_failure  ; then
    kcpmsg -l warn "unable to query resource set while deallocating subarray ${subarray}"
    return 1
  fi

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        t=${resource%:*}
        if [ "${var_result[${t}:type]}" = roach ] ; then
          board=${t#resources:}
          pool+=("${board}")
        fi
      fi
    fi
  done

# if already programmed, things may take longer, thus run it in parallel
  list="${pool[*]}"
  kcppar -n -s "${list// /,}" -x progdev

  count=0

  push_failure

  for resource in "${!var_result[@]}" ; do
    if [ "${resource##*:}" = holder ] ; then
      if [ "${var_result[${resource}]}" = "${subarray}" ] ; then
        t=${resource%:*}
        if [ "${var_result[${t}:type]}" = roach ] ; then
          board=${t#resources:}

          if kcpcmd -f -kr -s ${board}:7147 progdev ; then
            now=$(date +%s)
            if [ -n "${now}" ] ; then
              send_request   var-delete  "${t}:when"
              retrieve_reply var-delete
              send_request   var-set     "resources" ${now} string ":${board}:when"
              retrieve_reply var-set
            fi

          else
            kcpmsg -l error "unable to deprogram roach ${board} which was part of array ${subarray}"
          fi
        fi

        send_request   var-delete  "${resource}"
        retrieve_reply var-delete

        count=$[count+1]

      fi
    fi
  done

  kcpmsg -l info "attempted to release ${count} resources previously held by ${subarray}"

  if ! pop_failure  ; then
    kcpmsg -l error "unable to free all resources held by ${subarray}"
  fi
}

### api functions ### instrument ########################

function instrument_list()
{
  local -A size input outputs
  local -a index
  local instrument key

  shift

  if ! setup_instruments ; then
    echo "!instrument-list fail"
    return 1
  fi

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "instrument-size:$1"
  else
    fetch_var "instrument-size"
  fi

  if ! pop_failure  ; then
    kcpmsg -l error "unable to retrieve instrument list"
    echo "!instrument-list fail"
  fi

  for key in "${!var_result[@]}" ; do
    instrument="${key#instrument-size:}"
    index+=("${instrument}")
  done

  for instrument in "${index[@]}" ; do
    push_failure

    fetch_var "instrument-size:${instrument}"
    size="${var_result[*]}"

    fetch_var "instrument-input:${instrument}"
    input="${var_result[*]}"

    fetch_var "instrument-outputs:${instrument}"
    outputs="${var_result[*]}"

    if ! pop_failure  ; then
      kcpmsg -l warn "unable to retrieve needed information for instrument ${instrument}"
    else
      echo "#instrument-list ${instrument} sufficient ${size} ${input} ${outputs}"
    fi
  done

  echo "!instrument-list ok"
}

### api functions ### resources #########################

function resource_reload()
{
  if check_resources ; then
    echo "!resource-reload ok"
  else
    echo "!resource-reload fail"
  fi
}

function resource_list()
{
  local key board tmp
  local -A vector

  shift

  check_resources

  push_failure

  if [ -n "$1" ] ; then
    fetch_var "resources:$1"
  else
    fetch_var "resources"
  fi

  if ! pop_failure  ; then
    kcpmsg -l error "unable to retrieve resource variables"
    echo "!resource-list fail"
  fi

  for key in "${!var_result[@]}" ; do
    tmp="${key#resources:}"
    board="${tmp%%:*}"

    vector[${board}]="#resource-list ${board} ${var_result[resources:${board}:status]} ${var_result[resources:${board}:holder]}"
  done

  for key in "${vector[@]}" ; do
    echo "$key"
  done

  echo "!resource-list ok"
}

function resource_mark()
{
  local board status

  shift
  
  board=$1
  status=$2

  check_resources

  push_failure

  fetch_var "resources:${board}"

  if ! pop_failure  ; then
    kcpmsg -l error "unable to retrieve resource ${board}"
    echo "!resource-mark fail unknown-item"
    return 1
  fi

  case "${status}" in
    (up)
      if [ "${var_result[resources:${board}:type]}" = "roach" ] ; then
        if ! kcpcmd -k -r -i -s "${board}" watchdog >& /dev/null ; then
          if [ "${state/missing-roaches/}" = "${state}" ] ; then
            kcpmsg -l error "resource ${board} unresponsive"
            echo "!resource-mark fail network"
            return 1
          fi
          kcpmsg -l warn "roach resource ${board} not responsive but taking it to be ok"
        fi
      fi

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "up" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" up     string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (standby)

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" standby  string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "user" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" user   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (reset)

      if [ "${var_result[resources:${board}:type]}" != roach ] ; then
        kcpmsg -l warn "no way of resetting resource ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      if [ -n "${var_result[resources:${board}:holder]}" ] ; then
        kcpmsg -l warn "unwilling to reset resource ${board} as it is used by ${var_result[resources:${board}:holder]}"
        echo "!resource-mark fail in-use"
        return 1
      fi

      push_failure

      if [ "${var_result[resources:${board}:status]}" != "standby" ] ; then
        send_request   var-delete  "resources:${board}:status"
        retrieve_reply var-delete

        send_request   var-set  "resources" standby  string ":${board}:status"
        retrieve_reply var-set
      fi

      if [ "${var_result[resources:${board}:mode]}" != "auto" ] ; then
        send_request   var-delete  "resources:${board}:mode"
        retrieve_reply var-delete

        send_request   var-set  "resources" auto   string ":${board}:mode"
        retrieve_reply var-set
      fi

      if ! pop_failure  ; then
        kcpmsg -l error "unable to update resource state for ${board}"
        echo "!resource-mark fail read-logs"
        return 1
      fi

      if ! kcpcmd -k -i -r -s "$1" restart ; then
        kcpmsg -l error "unable to restart resource ${board}"
        echo "!resource-mark fail network"
        return 1
      fi

      echo "!resource-mark ok"
      return 0
    ;;
    (*)
      kcpmsg -l error "unknown marking ${status} for resource ${board}"
      echo "!resource-mark fail usage"
      return 1
    ;;
  esac
}

### api functions ### subordinates ######################

function subordinate_list()
{
  local -A ports hosts groups
  local -a v
  local group port host key
  local c t

  shift

  push_failure

  send_request    listener-list "$*"
  retrieve_inform listener-list

  if ! pop_failure ; then
    echo "!subordinate-list fail"
    return 1
  fi

# WARNING: we assume one listener per group here

  kcpmsg -l debug "my keys are ${!inform_result[@]}"
  for key in "${!inform_result[@]}" ; do
    v=(${inform_result[${key}]})
    if [ -z "${v[2]}" ] ; then
      group="${key}"
    else
      group=${v[2]}
    fi
    
    ports[${key}]=${v[0]}
    hosts[${key}]=${v[1]}
    groups[${key}]=${group}

  done

  push_failure

  c=0
  for key in "${!groups[@]}" ; do

    group="${groups[${key}]}"

    fetch_var  "${group}*subordinate*"

    if clear_failure ; then

      subarray="${var_result[${group}*subordinate*]}"

      if [ -n "${subarray}" ] ; then

        if [ "${key}" != "${subarray}" ] ; then
          kcpmsg -l warn "possible consistency issue where listener label ${key} does not match subarray name ${subarray}"
        fi

        port=${ports[${group}]}
        host=${hosts[${group}]}

        kcpmsg -l debug "considering ${group} with listener ${host}:${port}"


        if [ "${host}" = "0.0.0.0" ] ; then
          unset host
        fi

        fetch_var "${group}*inputs*"

        if clear_failure ; then
          echo "#subordinate-list "${subarray}" ${host}${host:+:}${port} ${var_result[*]}"
          c=$[c+1]
        fi

      fi

    fi
  done

  pop_failure

  if [ "${c}" -lt "$#"  ] ; then
    kcpmsg -l debug "was given $# parameters, could only list ${c} subarrays"
    echo "!subordinate-list fail unknown-array"
    return 1
  fi

  echo "!subordinate-list ok"
  return 0
}

function subordinate_create()
{
  local port key prefix group file
  local i t

  shift

  key=$1
  
# TODO: process key into group name via prefix

  group=${key}
  
  push_failure

  send_request   group-list "${group}"
  retrieve_reply group-list

  if pop_failure ; then
    kcpmsg -l warn "array ${group} already in use"
    echo "!subordinate-create fail already-exists"
    return 1
  fi

#   for instrument in ${instruments_deployed[*]} ; do
#     if [ ${instruments_inputs[${instrument}]} = "$#" ] ; then
#       match=$[match+1]
#     fi
#   done
# 
#   if [ "${match}" -le "0" ] ; then
#     kcpmsg -l error "no instruments available for a subarray of $# inputs"
#     echo "!subordinate-create fail unsupported-size"
#     return
#   fi
# 
#   kcpmsg -l info "have ${match} instruments on offer for a subarray of $# inputs"

  if [ -n "${CORR_DIR}" ] ; then
    for file in ${CORR_DIR}/${key}-* ; do
      if [ -f ${file} ] ; then
        if rm ${file} ; then
          kcpmsg -l debug "removing old config ${file}"
        else
          kcpmsg -l error "unable to remove old config file ${file}"
#        echo "!subordinate-create fail read-logs"
#        return
        fi
      fi
    done
  fi

  push_failure

  send_request   group-create "${group}"
  retrieve_reply group-create

  if ! pop_failure ; then
    kcpmsg -l warn "unable to create group ${group} for array"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

# TODO: a prune_holder here, to clean out stale resources 

# WARNING: we have created the group - now committed to deleting it on failure ... 

  push_failure

  send_request   var-declare "${group}*subordinate*" string
  retrieve_reply var-declare

  send_request   var-set "${group}*subordinate*" "$key" string
  retrieve_reply var-set

  send_request   var-declare "${group}*inputs*" array
  retrieve_reply var-declare

  shift
  i=0

  while [ "$#" -ge 1 ] ; do
    send_request   var-set "${group}*inputs*" "$1" string "#$i"
    retrieve_reply var-set

    shift
    i=$[i+1]
  done

  if ! clear_failure ; then

    send_request   group-halt "${group}"
    retrieve_reply group-halt
    
    pop_failure

    kcpmsg -l warn "unable to record inputs for group ${group}"
    echo "!subordinate-create fail read-logs"
    return 1
  fi

  if [ "${key}" = "rts" ] ; then
    port=${rts_port:-7404}
    kcpmsg "using hardcoded port ${port} for rts array"
  else
    t="${key//[^0-9]/}"
    if [ "$t" -gt 0 ] ; then
      port=$[base_port+t]
      if [ "$port" -gt "${base_port}" ] ; then
        kcpmsg "selecting name derived port ${port}"
      else
        kcpmsg -l warn "malformed port ${port} thus falling back to automatic selection"
        port=0
      fi
    else
      kcpmsg "will select a free port for array other than rts"
      port=0
    fi
  fi

  push_failure

  send_request   listener-create "${key}" "${port}" "0.0.0.0" "${group}"
  retrieve_reply listener-create

  if [ "${port}" -le "0" ] ; then
    send_request listener-list "${key}"
    retrieve_inform listener-list "${key}"
    port=${inform_result[${key}]%% *}
    if [ "${port}" -le "0" ] ; then
      kcpmsg -l error "unable to determine port for ${key} - got ${result}"
      set_failure
    fi
  fi

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start listener for group ${group}"
    echo "!subordinate-create fail network"
    return 1
  fi

  send_request   client-exec subordinate ${key} cmc-subordinate ${key} $*
  retrieve_reply client-exec

  if ! clear_failure ; then
    send_request   group-halt "${key}"
    retrieve_reply group-halt

    pop_failure

    kcpmsg -l warn "unable to start control task for group ${group}"
    echo "!subordinate-create fail task-start"
    return 1
  fi

  pop_failure

#  make_subarray_sensors ${key}

  echo "!subordinate-create ok ${port}"
  return 0
}

function subordinate_halt()
{
  local group key

  shift

  key="$1"

  if [ -z "${key}" ] ; then
    kcpmsg -l error "need a subarray to destroy"
    echo "!subordinate-halt fail usage"
    return 1
  fi

  group="${key}"

  push_failure

  fetch_var "${group}*subordinate*"

  if ! pop_failure ; then
    kcpmsg -l error "could not locate variable suborinate in group ${group}"

    kcpmsg -l error "subarray ${key} not found and so not halted"

    echo "!subordinate-halt fail unknown-item"
    return 1
  fi

  push_failure

  send_request    group-halt "$key"
  retrieve_reply  group-halt

  if ! pop_failure ; then
    echo "!subordinate-halt fail read-logs"
    return 1
  fi

  echo "!subordinate-halt ok"
  return 0
}

### main loop ###########################################

push_failure
send_request   client-config info-all
retrieve_reply client-config
send_request   log-limit off
retrieve_reply log-limit
pop_failure

check_resources

while read line ; do
  add_queue ${line}
#  show_queue

  k=0
  while [ "${k}" -lt "${queue_tail}" ] ; do

    string=${queue_data[${k}]}
    k=$[k+1]

    if [ "${string:0:1}" = "?" ] ; then

      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -z "${command_set[${cmd}]}" ] ; then
        kcpmsg -l warn "cmc primary got unsupported request ${cmd}"
        echo "!${cmd} fail unknown-item"
      else
        if [ "${command_size}" -lt "${command_set[${cmd}]}" ] ; then
          kcpmsg -l warn "need at least ${command_set[${cmd}]} parameters for ${cmd} but saw only ${command_size}"
          echo "!${cmd} fail usage"
        else
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi
      fi

    elif [ "${string:0:1}" = '#' ] ; then
      make_vector ${string}

      first=${command_vector[0]}
      cmd=${first:1}

      if [ -n "${inform_set[${cmd}]}" ] ; then
        if [ "${command_size}" -ge "${inform_set[${cmd}]}" ] ; then
          actual=${cmd//-/_}
          ${actual} ${command_vector[@]}
        fi
      fi

    fi

  done

  clear_queue
 
done
